{"version":3,"sources":["~lib/rt/common.ts","assembly/tms9918a.ts","assembly/f18a.ts"],"names":[],"mappings":"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","sourceRoot":"./index","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","const MODE_GRAPHICS = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_BITMAP = 2;\r\nconst MODE_MULTICOLOR = 3;\r\nconst MODE_BITMAP_TEXT = 4;\r\nconst MODE_BITMAP_MULTICOLOR = 5;\r\nconst MODE_ILLEGAL = 6;\r\n\r\nconst vdpRAMAddr = 0x00000;\r\nconst paletteAddr = 0x10000;\r\nconst scanlineColorBufferAddr = 0x11000;\r\nconst spriteBufferAddr = 0x12000;\r\n\r\nexport function drawScanline(\r\n    y: i32,\r\n    width: i32,\r\n    height: i32,\r\n    screenMode: i32,\r\n    textMode: bool,\r\n    bitmapMode: bool,\r\n    fgColor: i32,\r\n    bgColor: i32,\r\n    nameTable: i32,\r\n    colorTable: i32,\r\n    charPatternTable: i32,\r\n    colorTableMask: i32,\r\n    patternTableMask: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    vr1: i32,\r\n    vr4: i32,\r\n    displayOn: bool,\r\n    statusRegister: u8\r\n): u8 {\r\n    const\r\n        drawWidth: i32 = !textMode ? 256 : 240,\r\n        drawHeight: i32 = 192,\r\n        hBorder: i32 = (width - drawWidth) >> 1,\r\n        vBorder: i32 = (height - drawHeight) >> 1,\r\n        spriteSize: bool = (vr1 & 0x2) !== 0,\r\n        spriteMagnify: i32 = vr1 & 0x1,\r\n        spriteDimension: i32 = (spriteSize ? 16 : 8) << (spriteMagnify ? 1 : 0),\r\n        maxSpritesOnLine: i32 = 4;\r\n    let\r\n        imageDataAddr: i32 = 0,\r\n        collision: bool = false,\r\n        fifthSprite: bool = false,\r\n        fifthSpriteIndex: u8 = 31,\r\n        x: i32,\r\n        color: i32 = 0,\r\n        rgbColor: u32,\r\n        name: i32,\r\n        tableOffset: i32,\r\n        colorByte: i32,\r\n        patternByte: i32;\r\n\r\n    if (y >= vBorder && y < vBorder + drawHeight && displayOn) {\r\n        const yScreen: i32 = y - vBorder;\r\n        // Pre-process sprites\r\n        if (!textMode) {\r\n            initSpriteBuffer();\r\n            let spritesOnLine: i32 = 0;\r\n            let endMarkerFound: bool = false;\r\n            let spriteAttributeAddr: i32 = spriteAttributeTable;\r\n            let spriteIndex: i32;\r\n            for (spriteIndex = 0; spriteIndex < 32 && spritesOnLine <= maxSpritesOnLine && !endMarkerFound; spriteIndex++) {\r\n                let ySpriteTop: i32 = getRAMByte(spriteAttributeAddr);\r\n                if (ySpriteTop !== 0xD0) {\r\n                    if (ySpriteTop > 0xD0) {\r\n                        ySpriteTop -= 256;\r\n                    }\r\n                    ySpriteTop++;\r\n                    const ySpriteBottom: i32 = ySpriteTop + spriteDimension;\r\n                    let yAdjusted: i32 = -1;\r\n                    if (spriteIndex < 8 || !bitmapMode || (vr4 & 0x03) === 3) {\r\n                        if (yScreen >= ySpriteTop && yScreen < ySpriteBottom) {\r\n                            yAdjusted = yScreen;\r\n                        }\r\n                    } else {\r\n                        // Emulate sprite duplication bug\r\n                        const yMasked: i32 = (yScreen - 1) & (((vr4 & 0x03) << 6) | 0x3F);\r\n                        if (yMasked >= ySpriteTop && yMasked < ySpriteBottom) {\r\n                            yAdjusted = yMasked;\r\n                        } else if (yScreen >= 64 && yScreen < 128 && yScreen >= ySpriteTop && yScreen < ySpriteBottom) {\r\n                            yAdjusted = yScreen;\r\n                        }\r\n                    }\r\n                    if (yAdjusted !== -1) {\r\n                        if (spritesOnLine < maxSpritesOnLine) {\r\n                            let xSprite: i32 = getRAMByte(spriteAttributeAddr + 1);\r\n                            const sPatternNo: i32 = getRAMByte(spriteAttributeAddr + 2) & (spriteSize ? 0xFC : 0xFF);\r\n                            const sColor: i32 = getRAMByte(spriteAttributeAddr + 3) & 0x0F;\r\n                            if ((getRAMByte(spriteAttributeAddr + 3) & 0x80) !== 0) {\r\n                                xSprite -= 32;\r\n                            }\r\n                            const sLine: i32 = (yAdjusted - ySpriteTop) >> spriteMagnify;\r\n                            const sPatternBase: i32 = spritePatternTable + (sPatternNo << 3) + sLine;\r\n                            for (let sx1: i32 = 0; sx1 < spriteDimension; sx1++) {\r\n                                const sx2: i32 = xSprite + sx1;\r\n                                if (sx2 >= 0 && sx2 < drawWidth) {\r\n                                    const sx3: i32 = sx1 >> spriteMagnify;\r\n                                    const sPatternByte: i32 = getRAMByte(sPatternBase + (sx3 >= 8 ? 16 : 0));\r\n                                    if ((sPatternByte & (0x80 >> (sx3 & 0x07))) !== 0) {\r\n                                        if (getSpriteBuffer(sx2) === -1) {\r\n                                            setSpriteBuffer(sx2, sColor);\r\n                                        } else {\r\n                                            collision = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        spritesOnLine++;\r\n                    }\r\n                    spriteAttributeAddr += 4;\r\n                } else {\r\n                    endMarkerFound = true;\r\n                }\r\n            }\r\n            if (spritesOnLine === 5 && !fifthSprite) {\r\n                fifthSprite = true;\r\n                fifthSpriteIndex = <u8> spriteIndex - 1;\r\n            }\r\n        }\r\n        // Draw\r\n        const rowOffset: i32 = !textMode ? (yScreen >> 3) << 5 : (yScreen >> 3) * 40;\r\n        let lineOffset: i32 = yScreen & 7;\r\n        for (x = 0; x < width; x++) {\r\n            if (x >= hBorder && x < hBorder + drawWidth) {\r\n                const x1: i32 = x - hBorder;\r\n                // Tiles\r\n                switch (screenMode) {\r\n                    case MODE_GRAPHICS:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        colorByte = getRAMByte(colorTable + (name >> 3));\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_BITMAP:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        colorByte = getRAMByte(colorTable + (tableOffset & colorTableMask) + lineOffset);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (yScreen & 0x1C) >> 2;\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (yScreen & 0x1C) >> 2;\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_ILLEGAL:\r\n                        color = (x1 & 4) === 0 ? fgColor : bgColor;\r\n                        break;\r\n                }\r\n                if (color === 0) {\r\n                    color = bgColor;\r\n                }\r\n                // Sprites\r\n                if (!textMode) {\r\n                    const spriteColor: i32 = getSpriteBuffer(x1);\r\n                    if (spriteColor > 0) {\r\n                        color = spriteColor;\r\n                    }\r\n                }\r\n            } else {\r\n                color = bgColor;\r\n            }\r\n            rgbColor = getColor(color);\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    } else {\r\n        // Top/bottom border\r\n        rgbColor = getColor(bgColor);\r\n        for (x = 0; x < width; x++) {\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    }\r\n    if (y === vBorder + drawHeight) {\r\n        statusRegister |= 0x80;\r\n    }\r\n    if (collision) {\r\n        statusRegister |= 0x20;\r\n    }\r\n    if ((statusRegister & 0x40) === 0) {\r\n        statusRegister = (statusRegister & 0xe0) | fifthSpriteIndex;\r\n        if (fifthSprite) {\r\n            statusRegister |= 0x40;\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getRAMByte(addr: i32): u8 {\r\n    return load<u8>(vdpRAMAddr + addr);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getColor(i: i32): u32 {\r\n    return load<u32>(paletteAddr + (i << 2));\r\n}\r\n\r\nfunction initSpriteBuffer(): void {\r\n    memory.fill(spriteBufferAddr, 0xff, 256 << 2);\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpriteBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spriteBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpriteBuffer(offset: i32): i32 {\r\n    return load<i32>(spriteBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction setImageData(addr: i32, value: u32): void {\r\n    store<u32>(scanlineColorBufferAddr + (addr << 2), value);\r\n}\r\n","const MODE_GRAPHICS = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_TEXT_80 = 2;\r\nconst MODE_BITMAP = 3;\r\nconst MODE_MULTICOLOR = 4;\r\n\r\nconst COLOR_MODE_NORMAL = 0;\r\nconst COLOR_MODE_ECM_1 = 1;\r\nconst COLOR_MODE_ECM_2 = 2;\r\nconst COLOR_MODE_ECM_3 = 3;\r\n\r\nconst vdpRAMAddr = 0x00000;\r\nconst paletteAddr = 0x10000;\r\nconst scanlineColorBufferAddr = 0x11000;\r\nconst spriteColorBufferAddr = 0x12000;\r\nconst spritePaletteBaseIndexBufferAddr = 0x13000;\r\n\r\nlet pixelTilePriority: bool = false;\r\nlet pixelTransparentColor0: bool = false;\r\nlet pixelColor: i32 = 0;\r\nlet pixelPaletteBaseIndex: i32 = 0;\r\n\r\nexport function drawScanline(\r\n    y: i32,\r\n    displayOn: bool,\r\n    topBorder: i32,\r\n    drawHeight: i32,\r\n    unlocked: bool,\r\n    screenMode: i32,\r\n    drawWidth: i32,\r\n    vPageSize1: i32,\r\n    vPageSize2: i32,\r\n    hPageSize1: i32,\r\n    hPageSize2: i32,\r\n    vScroll1: i32,\r\n    vScroll2: i32,\r\n    tileLayer2Enabled: bool,\r\n    bitmapEnable: bool,\r\n    bitmapBaseAddr: i32,\r\n    bitmapX: i32,\r\n    bitmapY: i32,\r\n    bitmapWidth: i32,\r\n    bitmapHeight: i32,\r\n    bitmapTransparent: bool,\r\n    bitmapFat: bool,\r\n    bitmapPriority: bool,\r\n    bitmapPaletteSelect: i32,\r\n    nameTable: i32,\r\n    nameTable2: i32,\r\n    canvasWidth: i32,\r\n    scanLines: bool,\r\n    bgColor: i32,\r\n    leftBorder: i32,\r\n    tileLayer1Enabled: bool,\r\n    tileMap2AlwaysOnTop: bool,\r\n    colorTable: i32,\r\n    colorTable2: i32,\r\n    hScroll1: i32,\r\n    hScroll2: i32,\r\n    tilePaletteSelect1: i32,\r\n    tilePaletteSelect2: i32,\r\n    tileColorMode: i32,\r\n    row30Enabled: bool,\r\n    spriteLinkingEnabled: bool,\r\n    realSpriteYCoord: bool,\r\n    maxSprites: i32,\r\n    maxScanlineSprites: i32,\r\n    spriteColorMode: i32,\r\n    spritePaletteSelect: i32,\r\n    spritePlaneOffset: i32,\r\n    spriteSize: i32,\r\n    spriteMag: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    ecmPositionAttributes: bool,\r\n    charPatternTable: i32,\r\n    tilePlaneOffset: i32,\r\n    patternTableMask: i32,\r\n    colorTableMask: i32,\r\n    fgColor: i32,\r\n    statusRegister: u8\r\n): u8 {\r\n    let imageDataAddr: i32 = 0;\r\n    if (displayOn && y >= topBorder && y < topBorder + drawHeight) {\r\n        y -= topBorder;\r\n        // Prepare sprites\r\n        if (unlocked || (screenMode !== MODE_TEXT && screenMode !== MODE_TEXT_80)) {\r\n            statusRegister = prepareSprites(\r\n                y,\r\n                drawWidth,\r\n                screenMode,\r\n                row30Enabled,\r\n                unlocked,\r\n                spriteLinkingEnabled,\r\n                realSpriteYCoord,\r\n                maxSprites,\r\n                maxScanlineSprites,\r\n                spriteColorMode,\r\n                spritePaletteSelect,\r\n                spritePlaneOffset,\r\n                spriteSize,\r\n                spriteMag,\r\n                spriteAttributeTable,\r\n                spritePatternTable,\r\n                statusRegister\r\n            );\r\n        }\r\n        let scrollWidth: i32 = drawWidth;\r\n        const scrollHeight: i32 = drawHeight;\r\n        // Border in text modes\r\n        const borderWidth: i32 = screenMode === MODE_TEXT ? 8 : (screenMode === MODE_TEXT_80 ? 16 : 0);\r\n        scrollWidth -= (borderWidth << 1);\r\n        // Prepare values for Tile layer 1\r\n        const nameTableCanonicalBase: i32 = vPageSize1 ? nameTable & 0x3000 : (hPageSize1 ? nameTable & 0x3800 : nameTable);\r\n        let nameTableBaseAddr: i32 = nameTable;\r\n        let y1: i32 = y + vScroll1;\r\n        if (y1 >= scrollHeight) {\r\n            y1 -= scrollHeight;\r\n            nameTableBaseAddr ^= vPageSize1;\r\n        }\r\n        let rowOffset: i32 = 0;\r\n        switch (screenMode) {\r\n            case MODE_GRAPHICS:\r\n            case MODE_BITMAP:\r\n            case MODE_MULTICOLOR:\r\n                rowOffset = (y1 >> 3) << 5;\r\n                break;\r\n            case MODE_TEXT:\r\n                rowOffset = (y1 >> 3) * 40;\r\n                break;\r\n            case MODE_TEXT_80:\r\n                rowOffset = (y1 >> 3) * 80;\r\n                break;\r\n        }\r\n        const lineOffset: i32 = y1 & 7;\r\n        // Prepare values for Tile layer 2\r\n        let rowOffset2: i32 = 0,\r\n            nameTableCanonicalBase2: i32 = 0,\r\n            nameTableBaseAddr2: i32 = 0,\r\n            lineOffset2: i32 = 0,\r\n            y12: i32 = 0;\r\n        if (tileLayer2Enabled) {\r\n            nameTableCanonicalBase2 = vPageSize2 ? nameTable2 & 0x3000 : (hPageSize2 ? nameTable2 & 0x3800 : nameTable2);\r\n            nameTableBaseAddr2 = nameTable2;\r\n            y12 = y + vScroll2;\r\n            if (y12 >= scrollHeight) {\r\n                y12 -= scrollHeight;\r\n                nameTableBaseAddr2 ^= vPageSize2;\r\n            }\r\n            switch (screenMode) {\r\n                case MODE_GRAPHICS:\r\n                case MODE_BITMAP:\r\n                case MODE_MULTICOLOR:\r\n                    rowOffset2 = (y12 >> 3) << 5;\r\n                    break;\r\n                case MODE_TEXT:\r\n                    rowOffset2 = (y12 >> 3) * 40;\r\n                    break;\r\n                case MODE_TEXT_80:\r\n                    rowOffset2 = (y12 >> 3) * 80;\r\n                    break;\r\n            }\r\n            lineOffset2 = y12 & 7;\r\n        }\r\n        // Prepare values for Bitmap layer\r\n        let bitmapX2: i32 = 0,\r\n            bitmapY1: i32 = 0,\r\n            bitmapY2: i32 = 0,\r\n            bitmapYOffset: i32 = 0;\r\n        if (bitmapEnable) {\r\n            bitmapX2 = bitmapX + bitmapWidth;\r\n            bitmapY1 = y - bitmapY;\r\n            bitmapY2 = bitmapY + bitmapHeight;\r\n            bitmapYOffset = bitmapY1 * bitmapWidth;\r\n        }\r\n        // Prepare values for sprite layer\r\n        const spritesEnabled: bool = unlocked || (screenMode !== MODE_TEXT && screenMode !== MODE_TEXT_80);\r\n        // Draw line\r\n        for (let xc: i32 = 0; xc < canvasWidth; xc++) {\r\n            // Draw pixel\r\n            let color: i32 = bgColor;\r\n            let paletteBaseIndex: i32 = 0;\r\n            if (xc >= leftBorder && xc < leftBorder + drawWidth) {\r\n                const x: i32 = xc - leftBorder;\r\n                let havePixel: bool = false,\r\n                    tilePriority: bool = false;\r\n                // Tile layer 1\r\n                if (tileLayer1Enabled) {\r\n                    drawTileLayer(\r\n                        x,\r\n                        y,\r\n                        y1,\r\n                        rowOffset,\r\n                        lineOffset,\r\n                        nameTableCanonicalBase,\r\n                        nameTableBaseAddr,\r\n                        colorTable,\r\n                        borderWidth,\r\n                        scrollWidth,\r\n                        hScroll1,\r\n                        hPageSize1,\r\n                        tilePaletteSelect1,\r\n                        screenMode,\r\n                        tileColorMode,\r\n                        unlocked,\r\n                        ecmPositionAttributes,\r\n                        charPatternTable,\r\n                        tilePlaneOffset,\r\n                        patternTableMask,\r\n                        colorTableMask,\r\n                        drawWidth,\r\n                        fgColor,\r\n                        bgColor\r\n                    );\r\n                    if (pixelColor > 0 || !pixelTransparentColor0) {\r\n                        color = pixelColor;\r\n                        paletteBaseIndex = pixelPaletteBaseIndex;\r\n                        tilePriority = pixelTilePriority;\r\n                        havePixel = true;\r\n                    }\r\n                }\r\n                // Bitmap layer\r\n                if (bitmapEnable) {\r\n                    const bmpX: i32 = screenMode !== MODE_TEXT_80 ? x : x >> 1;\r\n                    if (bmpX >= bitmapX && bmpX < bitmapX2 && y >= bitmapY && y < bitmapY2) {\r\n                        const bitmapX1: i32 = x - bitmapX;\r\n                        const bitmapPixelOffset: i32 = bitmapX1 + bitmapYOffset;\r\n                        const bitmapByte: i32 = <i32> getRAMByte(bitmapBaseAddr + (bitmapPixelOffset >> 2));\r\n                        let bitmapBitShift: i32,\r\n                            bitmapColor: i32;\r\n                        if (bitmapFat) {\r\n                            // 16 color bitmap with fat pixels\r\n                            bitmapBitShift = (2 - (bitmapPixelOffset & 2)) << 1;\r\n                            bitmapColor = (bitmapByte >> bitmapBitShift) & 0x0F;\r\n                        } else {\r\n                            // 4 color bitmap\r\n                            bitmapBitShift = (3 - (bitmapPixelOffset & 3)) << 1;\r\n                            bitmapColor = (bitmapByte >> bitmapBitShift) & 0x03;\r\n                        }\r\n                        if ((bitmapColor > 0 || !bitmapTransparent) && (bitmapPriority || !havePixel)) {\r\n                            color = bitmapColor;\r\n                            paletteBaseIndex = bitmapPaletteSelect;\r\n                        }\r\n                    }\r\n                }\r\n                // Tile layer 2\r\n                if (tileLayer2Enabled) {\r\n                    drawTileLayer(\r\n                        x,\r\n                        y,\r\n                        y1,\r\n                        rowOffset2,\r\n                        lineOffset2,\r\n                        nameTableCanonicalBase2,\r\n                        nameTableBaseAddr2,\r\n                        colorTable2,\r\n                        borderWidth,\r\n                        scrollWidth,\r\n                        hScroll2,\r\n                        hPageSize2,\r\n                        tilePaletteSelect2,\r\n                        screenMode,\r\n                        tileColorMode,\r\n                        unlocked,\r\n                        ecmPositionAttributes,\r\n                        charPatternTable,\r\n                        tilePlaneOffset,\r\n                        patternTableMask,\r\n                        colorTableMask,\r\n                        drawWidth,\r\n                        fgColor,\r\n                        bgColor\r\n                    );\r\n                    if (pixelColor > 0 || !pixelTransparentColor0) {\r\n                        color = pixelColor;\r\n                        paletteBaseIndex = pixelPaletteBaseIndex;\r\n                        tilePriority = pixelTilePriority || tileMap2AlwaysOnTop;\r\n                        havePixel = true;\r\n                    }\r\n                }\r\n                // Sprite layer\r\n                if (spritesEnabled && !(tilePriority && havePixel)) {\r\n                    const spriteColor: i32 = getSpriteColorBuffer(x) - 1;\r\n                    if (spriteColor > 0) {\r\n                        color = spriteColor;\r\n                        paletteBaseIndex = getSpritePaletteBaseIndexBuffer(x);\r\n                    }\r\n                }\r\n            }\r\n            // Draw pixel\r\n            const rgbColor: u32 = getColor(color + paletteBaseIndex);\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    } else {\r\n        // Empty scanline\r\n        const rgbColor: u32 = getColor(bgColor);\r\n        for (let xc: i32 = 0; xc < canvasWidth; xc++) {\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    }\r\n    if (scanLines && (y & 1) !== 0) {\r\n        // Dim last scan line\r\n        let imagedataAddr2: i32 = imageDataAddr - (canvasWidth << 2);\r\n        for (let xc: i32 = 0; xc < canvasWidth; xc++) {\r\n            const rgbColor: u32 = getImageData(imagedataAddr2);\r\n            setImageData(imagedataAddr2++, rgbColor); // TODO: * 0.75\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\nfunction drawTileLayer(\r\n    x: i32,\r\n    y: i32,\r\n    y1: i32,\r\n    rowOffset: i32,\r\n    lineOffset: i32,\r\n    nameTableCanonicalBase: i32,\r\n    nameTableBaseAddr: i32,\r\n    colorTable: i32,\r\n    borderWidth: i32,\r\n    scrollWidth: i32,\r\n    hScroll: i32,\r\n    hPageSize: i32,\r\n    tilePaletteSelect: i32,\r\n    screenMode: i32,\r\n    tileColorMode: i32,\r\n    unlocked: bool,\r\n    ecmPositionAttributes: bool,\r\n    charPatternTable: i32,\r\n    tilePlaneOffset: i32,\r\n    patternTableMask: i32,\r\n    colorTableMask: i32,\r\n    drawWidth: i32,\r\n    fgColor: i32,\r\n    bgColor: i32,\r\n): void {\r\n    let tilePriority: bool = false,\r\n        transparentColor0: bool = false,\r\n        tileColor: i32 = 0,\r\n        paletteBaseIndex: i32 = 0,\r\n        nameTableAddr: i32 = nameTableBaseAddr,\r\n        x1: i32 = x - borderWidth + (hScroll << (screenMode === MODE_TEXT_80 ? 1 : 0));\r\n    if (x1 >= scrollWidth) {\r\n        x1 -= scrollWidth;\r\n        nameTableAddr ^= hPageSize;\r\n    }\r\n    let charNo: i32,\r\n        bitShift: i32,\r\n        bit: i32,\r\n        patternAddr: i32,\r\n        patternByte: i32,\r\n        colorByte: i32 = 0,\r\n        tileAttributeByte: i32 = 0,\r\n        tilePaletteBaseIndex: i32 = 0,\r\n        lineOffset1: i32;\r\n    switch (screenMode) {\r\n        case MODE_GRAPHICS:\r\n            nameTableAddr += (x1 >> 3) + rowOffset;\r\n            charNo = getRAMByte(nameTableAddr);\r\n            bitShift = x1 & 7;\r\n            lineOffset1 = lineOffset;\r\n            if (tileColorMode !== COLOR_MODE_NORMAL) {\r\n                tileAttributeByte = getRAMByte(colorTable + (ecmPositionAttributes ? nameTableAddr - nameTableCanonicalBase : charNo));\r\n                tilePriority = (tileAttributeByte & 0x80) !== 0;\r\n                if ((tileAttributeByte & 0x40) !== 0) {\r\n                    // Flip X\r\n                    bitShift = 7 - bitShift;\r\n                }\r\n                if ((tileAttributeByte & 0x20) !== 0) {\r\n                    // Flip y\r\n                    lineOffset1 = 7 - lineOffset1;\r\n                }\r\n                transparentColor0 = (tileAttributeByte & 0x10) !== 0;\r\n            }\r\n            bit = 0x80 >> bitShift;\r\n            patternAddr = charPatternTable + (charNo << 3) + lineOffset1;\r\n            patternByte = getRAMByte(patternAddr);\r\n            switch (tileColorMode) {\r\n                case COLOR_MODE_NORMAL:\r\n                    const colorSet: i32 = getRAMByte(colorTable + (charNo >> 3));\r\n                    tileColor = (patternByte & bit) !== 0 ? (colorSet & 0xF0) >> 4 : colorSet & 0x0F;\r\n                    tilePaletteBaseIndex = tilePaletteSelect;\r\n                    transparentColor0 = true;\r\n                    tilePriority = false;\r\n                    break;\r\n                case COLOR_MODE_ECM_1:\r\n                    tileColor = ((patternByte & bit) >> (7 - bitShift));\r\n                    tilePaletteBaseIndex = (tilePaletteSelect & 0x20) | ((tileAttributeByte & 0x0f) << 1);\r\n                    break;\r\n                case COLOR_MODE_ECM_2:\r\n                    tileColor =\r\n                        ((patternByte & bit) >> (7 - bitShift)) |\r\n                        (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1);\r\n                    tilePaletteBaseIndex = ((tileAttributeByte & 0x0f) << 2);\r\n                    break;\r\n                case COLOR_MODE_ECM_3:\r\n                    tileColor =\r\n                        ((patternByte & bit) >> (7 - bitShift)) |\r\n                        (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1) |\r\n                        (((getRAMByte((patternAddr + (tilePlaneOffset << 1)) & 0x3fff) & bit) >> (7 - bitShift)) << 2);\r\n                    tilePaletteBaseIndex = ((tileAttributeByte & 0x0e) << 2);\r\n                    break;\r\n            }\r\n            paletteBaseIndex = tilePaletteBaseIndex;\r\n            break;\r\n        case MODE_BITMAP:\r\n            charNo = getRAMByte(nameTableAddr + (x1 >> 3) + rowOffset);\r\n            bitShift = x1 & 7;\r\n            bit = 0x80 >> bitShift;\r\n            const charSetOffset: i32 = (y & 0xC0) << 5;\r\n            patternByte = getRAMByte(charPatternTable + (((charNo << 3) + charSetOffset) & patternTableMask) + lineOffset);\r\n            const colorAddr: i32 = colorTable + (((charNo << 3) + charSetOffset) & colorTableMask) + lineOffset;\r\n            colorByte = getRAMByte(colorAddr);\r\n            tileColor = (patternByte & bit) !== 0 ? (colorByte & 0xF0) >> 4 : (colorByte & 0x0F);\r\n            paletteBaseIndex = tilePaletteSelect;\r\n            transparentColor0 = true;\r\n            break;\r\n        case MODE_TEXT:\r\n        case MODE_TEXT_80:\r\n            if (x >= borderWidth && x < drawWidth - borderWidth) {\r\n                nameTableAddr += x1 / 6 + rowOffset;\r\n                charNo = getRAMByte(nameTableAddr);\r\n                bitShift = x1 % 6;\r\n                lineOffset1 = lineOffset;\r\n                if (tileColorMode !== COLOR_MODE_NORMAL) {\r\n                    tileAttributeByte = getRAMByte(colorTable + (ecmPositionAttributes ? nameTableAddr - nameTableCanonicalBase : charNo));\r\n                    tilePriority = (tileAttributeByte & 0x80) !== 0;\r\n                    if ((tileAttributeByte & 0x40) !== 0) {\r\n                        // Flip X\r\n                        bitShift = 5 - bitShift;\r\n                    }\r\n                    if ((tileAttributeByte & 0x20) !== 0) {\r\n                        // Flip y\r\n                        lineOffset1 = 7 - lineOffset1;\r\n                    }\r\n                    transparentColor0 = (tileAttributeByte & 0x10) !== 0;\r\n                }\r\n                bit = 0x80 >> bitShift;\r\n                patternAddr = charPatternTable + (charNo << 3) + lineOffset1;\r\n                patternByte = getRAMByte(patternAddr);\r\n                switch (tileColorMode) {\r\n                    case COLOR_MODE_NORMAL:\r\n                        if (unlocked && ecmPositionAttributes) {\r\n                            tileAttributeByte = getRAMByte(colorTable + nameTableAddr - nameTableCanonicalBase);\r\n                            tileColor = (patternByte & bit) !== 0 ? tileAttributeByte >> 4 : tileAttributeByte & 0xF;\r\n                        } else {\r\n                            tileColor = (patternByte & bit) !== 0 ? fgColor : bgColor;\r\n                        }\r\n                        tilePaletteBaseIndex = tilePaletteSelect;\r\n                        transparentColor0 = true;\r\n                        tilePriority = false;\r\n                        break;\r\n                    case COLOR_MODE_ECM_1:\r\n                        tileColor = ((patternByte & bit) >> (7 - bitShift));\r\n                        tilePaletteBaseIndex = (tilePaletteSelect & 0x20) | ((tileAttributeByte & 0x0f) << 1);\r\n                        break;\r\n                    case COLOR_MODE_ECM_2:\r\n                        tileColor =\r\n                            ((patternByte & bit) >> (7 - bitShift)) |\r\n                            (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1);\r\n                        tilePaletteBaseIndex = ((tileAttributeByte & 0x0f) << 2);\r\n                        break;\r\n                    case COLOR_MODE_ECM_3:\r\n                        tileColor =\r\n                            ((patternByte & bit) >> (7 - bitShift)) |\r\n                            (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1) |\r\n                            (((getRAMByte((patternAddr + (tilePlaneOffset << 1)) & 0x3fff) & bit) >> (7 - bitShift)) << 2);\r\n                        tilePaletteBaseIndex = ((tileAttributeByte & 0x0e) << 2);\r\n                        break;\r\n                }\r\n            } else {\r\n                transparentColor0 = true;\r\n            }\r\n            break;\r\n        case MODE_MULTICOLOR:\r\n            charNo = getRAMByte(nameTableAddr + (x1 >> 3) + rowOffset);\r\n            colorByte = getRAMByte(charPatternTable + (charNo << 3) + ((y1 & 0x1c) >> 2));\r\n            tileColor = (x1 & 4) === 0 ? (colorByte & 0xf0) >> 4 : (colorByte & 0x0f);\r\n            paletteBaseIndex = tilePaletteSelect;\r\n            transparentColor0 = true;\r\n            break;\r\n    }\r\n    pixelTilePriority = tilePriority;\r\n    pixelTransparentColor0 = transparentColor0;\r\n    pixelColor = tileColor;\r\n    pixelPaletteBaseIndex = paletteBaseIndex;\r\n}\r\n\r\nfunction prepareSprites(\r\n    y: i32,\r\n    drawWidth: i32,\r\n    screenMode: i32,\r\n    row30Enabled: bool,\r\n    unlocked: bool,\r\n    spriteLinkingEnabled: bool,\r\n    realSpriteYCoord: bool,\r\n    maxSprites: i32,\r\n    maxScanlineSprites: i32,\r\n    spriteColorMode: i32,\r\n    spritePaletteSelect: i32,\r\n    spritePlaneOffset: i32,\r\n    defaultSpriteSize: i32,\r\n    spriteMag: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    statusRegister: u8\r\n): u8 {\r\n    initSpriteBuffer(drawWidth);\r\n    let spritesOnLine: i32 = 0;\r\n    const outOfScreenY: i32 = row30Enabled ? 0xF0 : 0xC0;\r\n    const negativeScreenY: i32 = row30Enabled ? 0xF0 : 0xD0;\r\n    const maxSpriteAttrAddr: i32 = spriteAttributeTable + (maxSprites << 2);\r\n    for (let spriteAttrAddr: i32 = spriteAttributeTable, index: i32 = 0;\r\n         (row30Enabled || getRAMByte(spriteAttrAddr) !== 0xd0) && spriteAttrAddr < maxSpriteAttrAddr && spritesOnLine <= maxScanlineSprites; spriteAttrAddr += 4, index++) {\r\n        let parentSpriteAttrAddr: i32 = -1;\r\n        if (spriteLinkingEnabled) {\r\n            const spriteLinkingAttr: i32 = getRAMByte(spriteAttributeTable + 0x80 + ((spriteAttrAddr - spriteAttributeTable) >> 2));\r\n            if ((spriteLinkingAttr & 0x20) !== 0) {\r\n                parentSpriteAttrAddr = spriteAttributeTable + ((spriteLinkingAttr & 0x1F) << 2);\r\n            }\r\n        }\r\n        let spriteY: i32 = <i32> getRAMByte(spriteAttrAddr);\r\n        if (parentSpriteAttrAddr !== -1) {\r\n            spriteY = (spriteY + getRAMByte(parentSpriteAttrAddr)) & 0xFF;\r\n        }\r\n        if (!realSpriteYCoord) {\r\n            spriteY++;\r\n        }\r\n        if (spriteY < outOfScreenY || spriteY > negativeScreenY) {\r\n            if (spriteY > negativeScreenY) {\r\n                spriteY -= 256;\r\n            }\r\n            const spriteAttr: i32 = getRAMByte(spriteAttrAddr + 3);\r\n            const spriteSize: i32 = !unlocked || (spriteAttr & 0x10) === 0 ? defaultSpriteSize : 1;\r\n            const spriteHeight: i32 = 8 << spriteSize; // 8 or 16\r\n            const spriteDimensionY: i32 = spriteHeight << spriteMag; // 8, 16 or 32\r\n            if (y >= spriteY && y < spriteY + spriteDimensionY) {\r\n                if (spritesOnLine < maxScanlineSprites) {\r\n                    //noinspection JSSuspiciousNameCombination\r\n                    const spriteWidth: i32 = spriteHeight;\r\n                    //noinspection JSSuspiciousNameCombination\r\n                    const spriteDimensionX: i32 = spriteDimensionY;\r\n                    let spriteX: i32 = getRAMByte(spriteAttrAddr + 1);\r\n                    if (parentSpriteAttrAddr === -1) {\r\n                        if ((spriteAttr & 0x80) !== 0) {\r\n                            spriteX -= 32; // Early clock\r\n                        }\r\n                    } else {\r\n                        // Linked\r\n                        spriteX = (spriteX + getRAMByte(parentSpriteAttrAddr + 1)) & 0xFF;\r\n                        if ((getRAMByte(parentSpriteAttrAddr + 3) & 0x80) !== 0) {\r\n                            spriteX -= 32; // Early clock of parent\r\n                        }\r\n                    }\r\n                    const patternNo: i32 = (getRAMByte(spriteAttrAddr + 2) & (spriteSize !== 0 ? 0xFC : 0xFF));\r\n                    const spriteFlipY: bool = unlocked && (spriteAttr & 0x20) !== 0;\r\n                    const spriteFlipX: bool = unlocked && (spriteAttr & 0x40) !== 0;\r\n                    const baseColor: i32 = spriteAttr & 0x0F;\r\n                    let sprPaletteBaseIndex: i32 = 0;\r\n                    switch (spriteColorMode) {\r\n                        case COLOR_MODE_NORMAL:\r\n                            sprPaletteBaseIndex = spritePaletteSelect;\r\n                            break;\r\n                        case COLOR_MODE_ECM_1:\r\n                            sprPaletteBaseIndex = (spritePaletteSelect & 0x20) | (baseColor << 1);\r\n                            break;\r\n                        case COLOR_MODE_ECM_2:\r\n                            sprPaletteBaseIndex = (baseColor << 2);\r\n                            break;\r\n                        case COLOR_MODE_ECM_3:\r\n                            sprPaletteBaseIndex = ((baseColor & 0x0e) << 2);\r\n                            break;\r\n                    }\r\n                    const spritePatternBaseAddr = spritePatternTable + (patternNo << 3);\r\n                    let dy: i32 = (y - spriteY) >> spriteMag;\r\n                    if (spriteFlipY) {\r\n                        dy = spriteHeight - dy - 1;\r\n                    }\r\n                    for (let dx: i32 = 0; dx < spriteWidth; dx += 8) {\r\n                        const spritePatternAddr: i32 = spritePatternBaseAddr + dy + (dx << 1);\r\n                        const spritePatternByte0: i32 = getRAMByte(spritePatternAddr);\r\n                        const spritePatternByte1: i32 = getRAMByte((spritePatternAddr + spritePlaneOffset) & 0x3fff);\r\n                        const spritePatternByte2: i32 = getRAMByte((spritePatternAddr + (spritePlaneOffset << 1)) & 0x3fff);\r\n                        let spriteBit: i32 = 0x80;\r\n                        let spriteBitShift2: i32 = 7;\r\n                        for (let spriteBitShift1: i32 = 0; spriteBitShift1 < 8; spriteBitShift1++) {\r\n                            let sprColor: i32 = 0;\r\n                            let pixelOn: bool = false;\r\n                            switch (spriteColorMode) {\r\n                                case COLOR_MODE_NORMAL:\r\n                                    pixelOn = (spritePatternByte0 & spriteBit) !== 0;\r\n                                    sprColor = pixelOn ? baseColor : 0;\r\n                                    break;\r\n                                case COLOR_MODE_ECM_1:\r\n                                    sprColor = (spritePatternByte0 & spriteBit) >> spriteBitShift2;\r\n                                    break;\r\n                                case COLOR_MODE_ECM_2:\r\n                                    sprColor =\r\n                                        ((spritePatternByte0 & spriteBit) >> spriteBitShift2) |\r\n                                        (((spritePatternByte1 & spriteBit) >> spriteBitShift2) << 1);\r\n                                    break;\r\n                                case COLOR_MODE_ECM_3:\r\n                                    sprColor =\r\n                                        ((spritePatternByte0 & spriteBit) >> spriteBitShift2) |\r\n                                        (((spritePatternByte1 & spriteBit) >> spriteBitShift2) << 1) |\r\n                                        (((spritePatternByte2 & spriteBit) >> spriteBitShift2) << 2);\r\n                                    break;\r\n                            }\r\n                            if (sprColor > 0 || pixelOn) {\r\n                                let x2: i32 = spriteX + (spriteFlipX ? spriteDimensionX - ((dx + spriteBitShift1 + 1) << spriteMag) : ((dx + spriteBitShift1) << spriteMag));\r\n                                if (x2 >= 0 && x2 < drawWidth) {\r\n                                    if (getSpriteColorBuffer(x2) === 0) {\r\n                                        setSpriteColorBuffer(x2, sprColor + 1); // Add one here so 0 means uninitialized. Subtract one before drawing.\r\n                                        setSpritePaletteBaseIndexBuffer(x2, sprPaletteBaseIndex);\r\n                                    } else {\r\n                                        statusRegister |= 0x20; // Collision\r\n                                    }\r\n                                }\r\n                                if (spriteMag) {\r\n                                    x2++;\r\n                                    if (x2 >= 0 && x2 < drawWidth) {\r\n                                        if (getSpriteColorBuffer(x2) === 0) {\r\n                                            setSpriteColorBuffer(x2, sprColor + 1); // Add one here so 0 means uninitialized. Subtract one before drawing.\r\n                                            setSpritePaletteBaseIndexBuffer(x2, sprPaletteBaseIndex);\r\n                                        } else {\r\n                                            statusRegister |= 0x20; // Collision\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            spriteBit >>= 1;\r\n                            spriteBitShift2--;\r\n                        }\r\n                    }\r\n                }\r\n                spritesOnLine++;\r\n                if (spritesOnLine === 5 && (statusRegister & 0x40) === 0) {\r\n                    statusRegister |= 0x40; // Fifth sprite\r\n                    statusRegister = <u8> ((statusRegister & 0xe0) | index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (screenMode === MODE_TEXT_80) {\r\n        for (let x1: i32 = drawWidth >> 1; x1 >= 0; x1--) {\r\n            const spriteColorBufferValue = getSpriteColorBuffer(x1);\r\n            const spritePaletteBaseIndexBufferValue = getSpritePaletteBaseIndexBuffer(x1);\r\n            setSpriteColorBuffer(x1 << 1, spriteColorBufferValue);\r\n            setSpritePaletteBaseIndexBuffer(x1 << 1, spritePaletteBaseIndexBufferValue);\r\n            setSpriteColorBuffer((x1 << 1) + 1, spriteColorBufferValue);\r\n            setSpritePaletteBaseIndexBuffer((x1 << 1) + 1, spritePaletteBaseIndexBufferValue);\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getRAMByte(addr: i32): u8 {\r\n    return load<u8>(vdpRAMAddr + addr);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getColor(i: i32): u32 {\r\n    return load<u32>(paletteAddr + (i << 2));\r\n}\r\n\r\nfunction initSpriteBuffer(drawWidth: i32): void {\r\n    memory.fill(spriteColorBufferAddr, 0x00, drawWidth << 2);\r\n    memory.fill(spritePaletteBaseIndexBufferAddr, 0x00, drawWidth << 2);\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpriteColorBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spriteColorBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpriteColorBuffer(offset: i32): i32 {\r\n    return load<i32>(spriteColorBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpritePaletteBaseIndexBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spritePaletteBaseIndexBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpritePaletteBaseIndexBuffer(offset: i32): i32 {\r\n    return load<i32>(spritePaletteBaseIndexBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction setImageData(addr: i32, value: u32): void {\r\n    store<u32>(scanlineColorBufferAddr + (addr << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getImageData(addr: i32): u32 {\r\n    return load<u32>(scanlineColorBufferAddr + (addr << 2));\r\n}\r\n"]}