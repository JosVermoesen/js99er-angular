{"version":3,"sources":["~lib/rt/common.ts","assembly/index.ts"],"names":[],"mappings":"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","sourceRoot":"./index","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","export function drawScanline(\r\n    y: i32,\r\n    width: i32,\r\n    height: i32,\r\n    screenMode: i32,\r\n    textMode: bool,\r\n    bitmapMode: bool,\r\n    fgColor: i32,\r\n    bgColor: i32,\r\n    nameTable: i32,\r\n    colorTable: i32,\r\n    charPatternTable: i32,\r\n    colorTableMask: i32,\r\n    patternTableMask: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    vr1: i32,\r\n    vr4: i32,\r\n    displayOn: bool,\r\n    statusRegister: u8\r\n): u8 {\r\n    const\r\n        MODE_GRAPHICS = 0,\r\n        MODE_TEXT = 1,\r\n        MODE_BITMAP = 2,\r\n        MODE_MULTICOLOR = 3,\r\n        MODE_BITMAP_TEXT = 4,\r\n        MODE_BITMAP_MULTICOLOR = 5,\r\n        MODE_ILLEGAL = 6,\r\n        drawWidth = !textMode ? 256 : 240,\r\n        drawHeight = 192,\r\n        hBorder = (width - drawWidth) >> 1,\r\n        vBorder = (height - drawHeight) >> 1,\r\n        spriteSize: bool = (vr1 & 0x2) !== 0,\r\n        spriteMagnify = vr1 & 0x1,\r\n        spriteDimension = (spriteSize ? 16 : 8) << (spriteMagnify ? 1 : 0),\r\n        maxSpritesOnLine = 4;\r\n    let\r\n        imageDataAddr: i32 = 0,\r\n        collision = false,\r\n        fifthSprite = false,\r\n        fifthSpriteIndex = 31,\r\n        x: i32,\r\n        color: i32 = 0,\r\n        rgbColor: u32,\r\n        name: i32,\r\n        tableOffset: i32,\r\n        colorByte: i32,\r\n        patternByte: i32;\r\n    if (y >= vBorder && y < vBorder + drawHeight && displayOn) {\r\n        const y1 = y - vBorder;\r\n        // Pre-process sprites\r\n        if (!textMode) {\r\n            initSpriteBuffer();\r\n            let spritesOnLine = 0;\r\n            let endMarkerFound = false;\r\n            let spriteAttributeAddr = spriteAttributeTable;\r\n            let s: i32;\r\n            for (s = 0; s < 32 && spritesOnLine <= maxSpritesOnLine && !endMarkerFound; s++) {\r\n                let sy = <i32>ramByte(spriteAttributeAddr);\r\n                if (sy !== 0xD0) {\r\n                    if (sy > 0xD0) {\r\n                        sy -= 256;\r\n                    }\r\n                    sy++;\r\n                    const sy1 = sy + spriteDimension;\r\n                    let y2 = -1;\r\n                    if (s < 8 || !bitmapMode || (vr4 & 0x03) === 3) {\r\n                        if (y1 >= sy && y1 < sy1) {\r\n                            y2 = y1;\r\n                        }\r\n                    } else {\r\n                        // Emulate sprite duplication bug\r\n                        const yMasked = (y1 - 1) & (((vr4 & 0x03) << 6) | 0x3F);\r\n                        if (yMasked >= sy && yMasked < sy1) {\r\n                            y2 = yMasked;\r\n                        } else if (y1 >= 64 && y1 < 128 && y1 >= sy && y1 < sy1) {\r\n                            y2 = y1;\r\n                        }\r\n                    }\r\n                    if (y2 !== -1) {\r\n                        if (spritesOnLine < maxSpritesOnLine) {\r\n                            let sx = ramByte(spriteAttributeAddr + 1);\r\n                            const sPatternNo = ramByte(spriteAttributeAddr + 2) & (spriteSize ? 0xFC : 0xFF);\r\n                            const sColor = ramByte(spriteAttributeAddr + 3) & 0x0F;\r\n                            if ((ramByte(spriteAttributeAddr + 3) & 0x80) !== 0) {\r\n                                sx -= 32;\r\n                            }\r\n                            const sLine = (y2 - sy) >> spriteMagnify;\r\n                            const sPatternBase = spritePatternTable + (sPatternNo << 3) + sLine;\r\n                            for (let sx1 = 0; sx1 < spriteDimension; sx1++) {\r\n                                const sx2 = sx + sx1;\r\n                                if (sx2 >= 0 && sx2 < drawWidth) {\r\n                                    const sx3 = sx1 >> spriteMagnify;\r\n                                    const sPatternByte = ramByte(sPatternBase + (sx3 >= 8 ? 16 : 0));\r\n                                    if ((sPatternByte & (0x80 >> (<u8>sx3 & 0x07))) !== 0) {\r\n                                        if (getSpriteBuffer(sx2) === -1) {\r\n                                            setSpriteBuffer(sx2, sColor);\r\n                                        } else {\r\n                                            collision = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        spritesOnLine++;\r\n                    }\r\n                    spriteAttributeAddr += 4;\r\n                } else {\r\n                    endMarkerFound = true;\r\n                }\r\n            }\r\n            if (spritesOnLine > 4) {\r\n                fifthSprite = true;\r\n                fifthSpriteIndex = s;\r\n            }\r\n        }\r\n        // Draw\r\n        const rowOffset = !textMode ? (y1 >> 3) << 5 : (y1 >> 3) * 40;\r\n        let lineOffset = y1 & 7;\r\n        for (x = 0; x < width; x++) {\r\n            if (x >= hBorder && x < hBorder + drawWidth) {\r\n                const x1 = x - hBorder;\r\n                // Tiles\r\n                switch (screenMode) {\r\n                    case MODE_GRAPHICS:\r\n                        name = ramByte(nameTable + rowOffset + (x1 >> 3));\r\n                        colorByte = ramByte(colorTable + (name >> 3));\r\n                        patternByte = ramByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_BITMAP:\r\n                        name = ramByte(nameTable + rowOffset + (x1 >> 3));\r\n                        tableOffset = ((y1 & 0xC0) << 5) + (name << 3);\r\n                        colorByte = ramByte(colorTable + (tableOffset & colorTableMask) + lineOffset);\r\n                        patternByte = ramByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_MULTICOLOR:\r\n                        name = ramByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (y1 & 0x1C) >> 2;\r\n                        patternByte = ramByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_TEXT:\r\n                        name = ramByte(nameTable + rowOffset + x1 / 6);\r\n                        patternByte = ramByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_TEXT:\r\n                        name = ramByte(nameTable + rowOffset + x1 / 6);\r\n                        tableOffset = ((y1 & 0xC0) << 5) + (name << 3);\r\n                        patternByte = ramByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_MULTICOLOR:\r\n                        name = ramByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (y1 & 0x1C) >> 2;\r\n                        tableOffset = ((y1 & 0xC0) << 5) + (name << 3);\r\n                        patternByte = ramByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_ILLEGAL:\r\n                        color = (x1 & 4) === 0 ? fgColor : bgColor;\r\n                        break;\r\n                }\r\n                if (color === 0) {\r\n                    color = bgColor;\r\n                }\r\n                // Sprites\r\n                if (!textMode) {\r\n                    const spriteColor = getSpriteBuffer(x1);\r\n                    if (spriteColor > 0) {\r\n                        color = spriteColor;\r\n                    }\r\n                }\r\n            } else {\r\n                color = bgColor;\r\n            }\r\n            rgbColor = getColor(color);\r\n            setImageData(imageDataAddr++, <u8>((rgbColor & 0xff0000) >> 16)); // R\r\n            setImageData(imageDataAddr++, <u8>((rgbColor & 0x00ff00) >> 8)); // G\r\n            setImageData(imageDataAddr++, <u8>(rgbColor & 0x0000ff)); // B\r\n            setImageData(imageDataAddr++, 0xff); // alpha\r\n        }\r\n    } else {\r\n        // Top/bottom border\r\n        rgbColor = getColor(bgColor);\r\n        for (x = 0; x < width; x++) {\r\n            setImageData(imageDataAddr++, <u8>((rgbColor & 0xff0000) >> 16)); // R\r\n            setImageData(imageDataAddr++, <u8>((rgbColor & 0x00ff00) >> 8)); // G\r\n            setImageData(imageDataAddr++, <u8>(rgbColor & 0x0000ff)); // B\r\n            setImageData(imageDataAddr++, 0xff); // alpha\r\n        }\r\n    }\r\n    if (y === vBorder + drawHeight) {\r\n        statusRegister |= 0x80;\r\n    }\r\n    if (collision) {\r\n        statusRegister |= 0x20;\r\n    }\r\n    if ((statusRegister & 0x40) === 0) {\r\n        statusRegister |= <u8>fifthSpriteIndex;\r\n    }\r\n    if (fifthSprite) {\r\n        statusRegister |= 0x40;\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\nfunction initSpriteBuffer(): void {\r\n    for (let i = 0; i < 256; i++) {\r\n        store<i8>(0x6000 + i, -1);\r\n    }\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpriteBuffer(offset: i32, value: i8): void {\r\n    store<i8>(0x6000 + offset, value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpriteBuffer(offset: i32): i8 {\r\n    return load<i8>(0x6000 + offset);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction ramByte(addr: i32): u8 {\r\n    return load<u8>(addr);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction setImageData(addr: i32, value: u8): void {\r\n    store<u8>(addr + 0x4000, value);\r\n}\r\n\r\nfunction getColor(i: i32): u32 {\r\n    switch (i & 15) {\r\n        case 0:\r\n            return 0x000000;\r\n        case 1:\r\n            return 0x000000;\r\n        case 2:\r\n            return 0x21c842;\r\n        case 3:\r\n            return 0x5edc78;\r\n        case 4:\r\n            return 0x5455ed;\r\n        case 5:\r\n            return 0x7d76fc;\r\n        case 6:\r\n            return 0xd4524d;\r\n        case 7:\r\n            return 0x42ebf5;\r\n        case 8:\r\n            return 0xfc5554;\r\n        case 9:\r\n            return 0xff7978;\r\n        case 10:\r\n            return 0xd4c154;\r\n        case 11:\r\n            return 0xe6ce80;\r\n        case 12:\r\n            return 0x21b03b;\r\n        case 13:\r\n            return 0xc95bba;\r\n        case 14:\r\n            return 0xcccccc;\r\n        case 15:\r\n            return 0xffffff;\r\n    }\r\n    return 0;\r\n}\r\n"]}