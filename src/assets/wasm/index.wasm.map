{"version":3,"sources":["~lib/rt/common.ts","assembly/tms9918a.ts","assembly/f18a.ts"],"names":[],"mappings":"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","sourceRoot":"./index","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","const MODE_GRAPHICS = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_BITMAP = 2;\r\nconst MODE_MULTICOLOR = 3;\r\nconst MODE_BITMAP_TEXT = 4;\r\nconst MODE_BITMAP_MULTICOLOR = 5;\r\nconst MODE_ILLEGAL = 6;\r\n\r\nconst vdpRAMAddr = 0x00000;\r\nconst paletteAddr = 0x10000;\r\nconst scanlineColorBufferAddr = 0x11000;\r\nconst spriteBufferAddr = 0x12000;\r\n\r\nexport function drawScanline(\r\n    y: i32,\r\n    width: i32,\r\n    height: i32,\r\n    screenMode: i32,\r\n    textMode: bool,\r\n    bitmapMode: bool,\r\n    fgColor: i32,\r\n    bgColor: i32,\r\n    nameTable: i32,\r\n    colorTable: i32,\r\n    charPatternTable: i32,\r\n    colorTableMask: i32,\r\n    patternTableMask: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    vr1: i32,\r\n    vr4: i32,\r\n    displayOn: bool,\r\n    statusRegister: u8\r\n): u8 {\r\n    const\r\n        drawWidth: i32 = !textMode ? 256 : 240,\r\n        drawHeight: i32 = 192,\r\n        hBorder: i32 = (width - drawWidth) >> 1,\r\n        vBorder: i32 = (height - drawHeight) >> 1,\r\n        spriteSize: bool = (vr1 & 0x2) !== 0,\r\n        spriteMagnify: i32 = vr1 & 0x1,\r\n        spriteDimension: i32 = (spriteSize ? 16 : 8) << (spriteMagnify ? 1 : 0),\r\n        maxSpritesOnLine: i32 = 4;\r\n    let\r\n        imageDataAddr: i32 = 0,\r\n        collision: bool = false,\r\n        fifthSprite: bool = false,\r\n        fifthSpriteIndex: u8 = 31,\r\n        x: i32,\r\n        color: i32 = 0,\r\n        rgbColor: u32,\r\n        name: i32,\r\n        tableOffset: i32,\r\n        colorByte: i32,\r\n        patternByte: i32;\r\n\r\n    if (y >= vBorder && y < vBorder + drawHeight && displayOn) {\r\n        const yScreen: i32 = y - vBorder;\r\n        // Pre-process sprites\r\n        if (!textMode) {\r\n            initSpriteBuffer();\r\n            let spritesOnLine: i32 = 0;\r\n            let endMarkerFound: bool = false;\r\n            let spriteAttributeAddr: i32 = spriteAttributeTable;\r\n            let spriteIndex: i32;\r\n            for (spriteIndex = 0; spriteIndex < 32 && spritesOnLine <= maxSpritesOnLine && !endMarkerFound; spriteIndex++) {\r\n                let ySpriteTop: i32 = getRAMByte(spriteAttributeAddr);\r\n                if (ySpriteTop !== 0xD0) {\r\n                    if (ySpriteTop > 0xD0) {\r\n                        ySpriteTop -= 256;\r\n                    }\r\n                    ySpriteTop++;\r\n                    const ySpriteBottom: i32 = ySpriteTop + spriteDimension;\r\n                    let yAdjusted: i32 = -1;\r\n                    if (spriteIndex < 8 || !bitmapMode || (vr4 & 0x03) === 3) {\r\n                        if (yScreen >= ySpriteTop && yScreen < ySpriteBottom) {\r\n                            yAdjusted = yScreen;\r\n                        }\r\n                    } else {\r\n                        // Emulate sprite duplication bug\r\n                        const yMasked: i32 = (yScreen - 1) & (((vr4 & 0x03) << 6) | 0x3F);\r\n                        if (yMasked >= ySpriteTop && yMasked < ySpriteBottom) {\r\n                            yAdjusted = yMasked;\r\n                        } else if (yScreen >= 64 && yScreen < 128 && yScreen >= ySpriteTop && yScreen < ySpriteBottom) {\r\n                            yAdjusted = yScreen;\r\n                        }\r\n                    }\r\n                    if (yAdjusted !== -1) {\r\n                        if (spritesOnLine < maxSpritesOnLine) {\r\n                            let xSprite: i32 = getRAMByte(spriteAttributeAddr + 1);\r\n                            const sPatternNo: i32 = getRAMByte(spriteAttributeAddr + 2) & (spriteSize ? 0xFC : 0xFF);\r\n                            const sColor: i32 = getRAMByte(spriteAttributeAddr + 3) & 0x0F;\r\n                            if ((getRAMByte(spriteAttributeAddr + 3) & 0x80) !== 0) {\r\n                                xSprite -= 32;\r\n                            }\r\n                            const sLine: i32 = (yAdjusted - ySpriteTop) >> spriteMagnify;\r\n                            const sPatternBase: i32 = spritePatternTable + (sPatternNo << 3) + sLine;\r\n                            for (let sx1: i32 = 0; sx1 < spriteDimension; sx1++) {\r\n                                const sx2: i32 = xSprite + sx1;\r\n                                if (sx2 >= 0 && sx2 < drawWidth) {\r\n                                    const sx3: i32 = sx1 >> spriteMagnify;\r\n                                    const sPatternByte: i32 = getRAMByte(sPatternBase + (sx3 >= 8 ? 16 : 0));\r\n                                    if ((sPatternByte & (0x80 >> (sx3 & 0x07))) !== 0) {\r\n                                        if (getSpriteBuffer(sx2) === -1) {\r\n                                            setSpriteBuffer(sx2, sColor);\r\n                                        } else {\r\n                                            collision = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        spritesOnLine++;\r\n                    }\r\n                    spriteAttributeAddr += 4;\r\n                } else {\r\n                    endMarkerFound = true;\r\n                }\r\n            }\r\n            if (spritesOnLine === 5 && !fifthSprite) {\r\n                fifthSprite = true;\r\n                fifthSpriteIndex = <u8> spriteIndex - 1;\r\n            }\r\n        }\r\n        // Draw\r\n        const rowOffset: i32 = !textMode ? (yScreen >> 3) << 5 : (yScreen >> 3) * 40;\r\n        let lineOffset: i32 = yScreen & 7;\r\n        for (x = 0; x < width; x++) {\r\n            if (x >= hBorder && x < hBorder + drawWidth) {\r\n                const x1: i32 = x - hBorder;\r\n                // Tiles\r\n                switch (screenMode) {\r\n                    case MODE_GRAPHICS:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        colorByte = getRAMByte(colorTable + (name >> 3));\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_BITMAP:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        colorByte = getRAMByte(colorTable + (tableOffset & colorTableMask) + lineOffset);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (yScreen & 0x1C) >> 2;\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (yScreen & 0x1C) >> 2;\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_ILLEGAL:\r\n                        color = (x1 & 4) === 0 ? fgColor : bgColor;\r\n                        break;\r\n                }\r\n                if (color === 0) {\r\n                    color = bgColor;\r\n                }\r\n                // Sprites\r\n                if (!textMode) {\r\n                    const spriteColor: i32 = getSpriteBuffer(x1);\r\n                    if (spriteColor > 0) {\r\n                        color = spriteColor;\r\n                    }\r\n                }\r\n            } else {\r\n                color = bgColor;\r\n            }\r\n            rgbColor = getColor(color);\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    } else {\r\n        // Top/bottom border\r\n        rgbColor = getColor(bgColor);\r\n        for (x = 0; x < width; x++) {\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    }\r\n    if (y === vBorder + drawHeight) {\r\n        statusRegister |= 0x80;\r\n    }\r\n    if (collision) {\r\n        statusRegister |= 0x20;\r\n    }\r\n    if ((statusRegister & 0x40) === 0) {\r\n        statusRegister = (statusRegister & 0xe0) | fifthSpriteIndex;\r\n        if (fifthSprite) {\r\n            statusRegister |= 0x40;\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getRAMByte(addr: i32): u8 {\r\n    return load<u8>(vdpRAMAddr + addr);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getColor(i: i32): u32 {\r\n    return load<u32>(paletteAddr + (i << 2));\r\n}\r\n\r\nfunction initSpriteBuffer(): void {\r\n    memory.fill(spriteBufferAddr, 0xff, 256 << 2);\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpriteBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spriteBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpriteBuffer(offset: i32): i32 {\r\n    return load<i32>(spriteBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction setImageData(addr: i32, value: u32): void {\r\n    store<u32>(scanlineColorBufferAddr + (addr << 2), value);\r\n}\r\n","const MODE_GRAPHICS = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_TEXT_80 = 2;\r\nconst MODE_BITMAP = 3;\r\nconst MODE_MULTICOLOR = 4;\r\n\r\nconst COLOR_MODE_NORMAL = 0;\r\nconst COLOR_MODE_ECM_1 = 1;\r\nconst COLOR_MODE_ECM_2 = 2;\r\nconst COLOR_MODE_ECM_3 = 3;\r\n\r\nconst vdpRAMAddr = 0x00000;\r\nconst paletteAddr = 0x10000;\r\nconst scanlineColorBufferAddr = 0x11000;\r\nconst spriteColorBufferAddr = 0x12000;\r\nconst spritePaletteBaseIndexBufferAddr = 0x13000;\r\n\r\nlet pixelTilePriority: bool = false;\r\nlet pixelTransparentColor0: bool = false;\r\nlet pixelColor: i32 = 0;\r\nlet pixelPaletteBaseIndex: i32 = 0;\r\n\r\nexport function drawScanline(\r\n    y: i32,\r\n    displayOn: bool,\r\n    topBorder: i32,\r\n    drawHeight: i32,\r\n    unlocked: bool,\r\n    screenMode: i32,\r\n    drawWidth: i32,\r\n    vPageSize1: i32,\r\n    vPageSize2: i32,\r\n    hPageSize1: i32,\r\n    hPageSize2: i32,\r\n    vScroll1: i32,\r\n    vScroll2: i32,\r\n    tileLayer2Enabled: bool,\r\n    bitmapEnable: bool,\r\n    bitmapBaseAddr: i32,\r\n    bitmapX: i32,\r\n    bitmapY: i32,\r\n    bitmapWidth: i32,\r\n    bitmapHeight: i32,\r\n    bitmapTransparent: bool,\r\n    bitmapFat: bool,\r\n    bitmapPriority: bool,\r\n    bitmapPaletteSelect: i32,\r\n    nameTable: i32,\r\n    nameTable2: i32,\r\n    canvasWidth: i32,\r\n    scanLines: bool,\r\n    bgColor: i32,\r\n    leftBorder: i32,\r\n    tileLayer1Enabled: bool,\r\n    tileMap2AlwaysOnTop: bool,\r\n    colorTable: i32,\r\n    colorTable2: i32,\r\n    hScroll1: i32,\r\n    hScroll2: i32,\r\n    tilePaletteSelect1: i32,\r\n    tilePaletteSelect2: i32,\r\n    tileColorMode: i32,\r\n    row30Enabled: bool,\r\n    spriteLinkingEnabled: bool,\r\n    realSpriteYCoord: bool,\r\n    maxSprites: i32,\r\n    maxScanlineSprites: i32,\r\n    spriteColorMode: i32,\r\n    spritePaletteSelect: i32,\r\n    spritePlaneOffset: i32,\r\n    spriteSize: i32,\r\n    spriteMag: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    ecmPositionAttributes: bool,\r\n    charPatternTable: i32,\r\n    tilePlaneOffset: i32,\r\n    patternTableMask: i32,\r\n    colorTableMask: i32,\r\n    fgColor: i32,\r\n    statusRegister: u8\r\n): u8 {\r\n    let imageDataAddr: i32 = 0;\r\n    if (displayOn && y >= topBorder && y < topBorder + drawHeight) {\r\n        y -= topBorder;\r\n        // Prepare sprites\r\n        if (unlocked || (screenMode !== MODE_TEXT && screenMode !== MODE_TEXT_80)) {\r\n            statusRegister = prepareSprites(\r\n                y,\r\n                drawWidth,\r\n                screenMode,\r\n                row30Enabled,\r\n                unlocked,\r\n                spriteLinkingEnabled,\r\n                realSpriteYCoord,\r\n                maxSprites,\r\n                maxScanlineSprites,\r\n                spriteColorMode,\r\n                spritePaletteSelect,\r\n                spritePlaneOffset,\r\n                spriteSize,\r\n                spriteMag,\r\n                spriteAttributeTable,\r\n                spritePatternTable,\r\n                statusRegister\r\n            );\r\n        }\r\n        let scrollWidth: i32 = drawWidth;\r\n        const scrollHeight: i32 = drawHeight;\r\n        // Border in text modes\r\n        const borderWidth: i32 = screenMode === MODE_TEXT ? 8 : (screenMode === MODE_TEXT_80 ? 16 : 0);\r\n        scrollWidth -= (borderWidth << 1);\r\n        // Prepare values for Tile layer 1\r\n        const nameTableCanonicalBase: i32 = vPageSize1 ? nameTable & 0x3000 : (hPageSize1 ? nameTable & 0x3800 : nameTable);\r\n        let nameTableBaseAddr: i32 = nameTable;\r\n        let y1: i32 = y + vScroll1;\r\n        if (y1 >= scrollHeight) {\r\n            y1 -= scrollHeight;\r\n            nameTableBaseAddr ^= vPageSize1;\r\n        }\r\n        let rowOffset: i32 = 0;\r\n        switch (screenMode) {\r\n            case MODE_GRAPHICS:\r\n            case MODE_BITMAP:\r\n            case MODE_MULTICOLOR:\r\n                rowOffset = (y1 >> 3) << 5;\r\n                break;\r\n            case MODE_TEXT:\r\n                rowOffset = (y1 >> 3) * 40;\r\n                break;\r\n            case MODE_TEXT_80:\r\n                rowOffset = (y1 >> 3) * 80;\r\n                break;\r\n        }\r\n        const lineOffset: i32 = y1 & 7;\r\n        // Prepare values for Tile layer 2\r\n        let rowOffset2: i32 = 0,\r\n            nameTableCanonicalBase2: i32 = 0,\r\n            nameTableBaseAddr2: i32 = 0,\r\n            lineOffset2: i32 = 0,\r\n            y12: i32 = 0;\r\n        if (tileLayer2Enabled) {\r\n            nameTableCanonicalBase2 = vPageSize2 ? nameTable2 & 0x3000 : (hPageSize2 ? nameTable2 & 0x3800 : nameTable2);\r\n            nameTableBaseAddr2 = nameTable2;\r\n            y12 = y + vScroll2;\r\n            if (y12 >= scrollHeight) {\r\n                y12 -= scrollHeight;\r\n                nameTableBaseAddr2 ^= vPageSize2;\r\n            }\r\n            switch (screenMode) {\r\n                case MODE_GRAPHICS:\r\n                case MODE_BITMAP:\r\n                case MODE_MULTICOLOR:\r\n                    rowOffset2 = (y12 >> 3) << 5;\r\n                    break;\r\n                case MODE_TEXT:\r\n                    rowOffset2 = (y12 >> 3) * 40;\r\n                    break;\r\n                case MODE_TEXT_80:\r\n                    rowOffset2 = (y12 >> 3) * 80;\r\n                    break;\r\n            }\r\n            lineOffset2 = y12 & 7;\r\n        }\r\n        // Prepare values for Bitmap layer\r\n        let bitmapX2: i32 = 0,\r\n            bitmapY1: i32 = 0,\r\n            bitmapY2: i32 = 0,\r\n            bitmapYOffset: i32 = 0;\r\n        if (bitmapEnable) {\r\n            bitmapX2 = bitmapX + bitmapWidth;\r\n            bitmapY1 = y - bitmapY;\r\n            bitmapY2 = bitmapY + bitmapHeight;\r\n            bitmapYOffset = bitmapY1 * bitmapWidth;\r\n        }\r\n        // Prepare values for sprite layer\r\n        const spritesEnabled: bool = unlocked || (screenMode !== MODE_TEXT && screenMode !== MODE_TEXT_80);\r\n        // Draw line\r\n        for (let xc: i32 = 0; xc < canvasWidth; xc++) {\r\n            // Draw pixel\r\n            let color: i32 = bgColor;\r\n            let paletteBaseIndex: i32 = 0;\r\n            if (xc >= leftBorder && xc < leftBorder + drawWidth) {\r\n                const x: i32 = xc - leftBorder;\r\n                let havePixel: bool = false,\r\n                    tilePriority: bool = false;\r\n                // Tile layer 1\r\n                if (tileLayer1Enabled) {\r\n                    drawTileLayer(\r\n                        x,\r\n                        y,\r\n                        y1,\r\n                        rowOffset,\r\n                        lineOffset,\r\n                        nameTableCanonicalBase,\r\n                        nameTableBaseAddr,\r\n                        colorTable,\r\n                        borderWidth,\r\n                        scrollWidth,\r\n                        hScroll1,\r\n                        hPageSize1,\r\n                        tilePaletteSelect1,\r\n                        screenMode,\r\n                        tileColorMode,\r\n                        unlocked,\r\n                        ecmPositionAttributes,\r\n                        charPatternTable,\r\n                        tilePlaneOffset,\r\n                        patternTableMask,\r\n                        colorTableMask,\r\n                        drawWidth,\r\n                        fgColor,\r\n                        bgColor\r\n                    );\r\n                    if (pixelColor > 0 || !pixelTransparentColor0) {\r\n                        color = pixelColor;\r\n                        paletteBaseIndex = pixelPaletteBaseIndex;\r\n                        tilePriority = pixelTilePriority;\r\n                        havePixel = true;\r\n                    }\r\n                }\r\n                // Tile layer 2\r\n                if (tileLayer2Enabled) {\r\n                    drawTileLayer(\r\n                        x,\r\n                        y,\r\n                        y1,\r\n                        rowOffset2,\r\n                        lineOffset2,\r\n                        nameTableCanonicalBase2,\r\n                        nameTableBaseAddr2,\r\n                        colorTable2,\r\n                        borderWidth,\r\n                        scrollWidth,\r\n                        hScroll2,\r\n                        hPageSize2,\r\n                        tilePaletteSelect2,\r\n                        screenMode,\r\n                        tileColorMode,\r\n                        unlocked,\r\n                        ecmPositionAttributes,\r\n                        charPatternTable,\r\n                        tilePlaneOffset,\r\n                        patternTableMask,\r\n                        colorTableMask,\r\n                        drawWidth,\r\n                        fgColor,\r\n                        bgColor\r\n                    );\r\n                    if (pixelColor > 0 || !pixelTransparentColor0) {\r\n                        color = pixelColor;\r\n                        paletteBaseIndex = pixelPaletteBaseIndex;\r\n                        tilePriority = pixelTilePriority || tileMap2AlwaysOnTop;\r\n                        havePixel = true;\r\n                    }\r\n                }\r\n                // Bitmap layer\r\n                if (bitmapEnable) {\r\n                    const bmpX: i32 = screenMode !== MODE_TEXT_80 ? x : x >> 1;\r\n                    if (bmpX >= bitmapX && bmpX < bitmapX2 && y >= bitmapY && y < bitmapY2) {\r\n                        const bitmapX1: i32 = x - bitmapX;\r\n                        const bitmapPixelOffset: i32 = bitmapX1 + bitmapYOffset;\r\n                        const bitmapByte: i32 = <i32> getRAMByte(bitmapBaseAddr + (bitmapPixelOffset >> 2));\r\n                        let bitmapBitShift: i32,\r\n                            bitmapColor: i32;\r\n                        if (bitmapFat) {\r\n                            // 16 color bitmap with fat pixels\r\n                            bitmapBitShift = (2 - (bitmapPixelOffset & 2)) << 1;\r\n                            bitmapColor = (bitmapByte >> bitmapBitShift) & 0x0F;\r\n                        } else {\r\n                            // 4 color bitmap\r\n                            bitmapBitShift = (3 - (bitmapPixelOffset & 3)) << 1;\r\n                            bitmapColor = (bitmapByte >> bitmapBitShift) & 0x03;\r\n                        }\r\n                        if ((bitmapColor > 0 || !bitmapTransparent) && (bitmapPriority || !havePixel)) {\r\n                            color = bitmapColor;\r\n                            paletteBaseIndex = bitmapPaletteSelect;\r\n                        }\r\n                    }\r\n                }\r\n                // Sprite layer\r\n                if (spritesEnabled && !(tilePriority && havePixel)) {\r\n                    const spriteColor: i32 = getSpriteColorBuffer(x) - 1;\r\n                    if (spriteColor > 0) {\r\n                        color = spriteColor;\r\n                        paletteBaseIndex = getSpritePaletteBaseIndexBuffer(x);\r\n                    }\r\n                }\r\n            }\r\n            // Draw pixel\r\n            const rgbColor: u32 = getColor(color + paletteBaseIndex);\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    } else {\r\n        // Empty scanline\r\n        const rgbColor: u32 = getColor(bgColor);\r\n        for (let xc: i32 = 0; xc < canvasWidth; xc++) {\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    }\r\n    if (scanLines && (y & 1) !== 0) {\r\n        // Dim last scan line\r\n        let imagedataAddr2: i32 = imageDataAddr - (canvasWidth << 2);\r\n        for (let xc: i32 = 0; xc < canvasWidth; xc++) {\r\n            const rgbColor: u32 = getImageData(imagedataAddr2);\r\n            setImageData(imagedataAddr2++, rgbColor); // TODO: * 0.75\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\nfunction drawTileLayer(\r\n    x: i32,\r\n    y: i32,\r\n    y1: i32,\r\n    rowOffset: i32,\r\n    lineOffset: i32,\r\n    nameTableCanonicalBase: i32,\r\n    nameTableBaseAddr: i32,\r\n    colorTable: i32,\r\n    borderWidth: i32,\r\n    scrollWidth: i32,\r\n    hScroll: i32,\r\n    hPageSize: i32,\r\n    tilePaletteSelect: i32,\r\n    screenMode: i32,\r\n    tileColorMode: i32,\r\n    unlocked: bool,\r\n    ecmPositionAttributes: bool,\r\n    charPatternTable: i32,\r\n    tilePlaneOffset: i32,\r\n    patternTableMask: i32,\r\n    colorTableMask: i32,\r\n    drawWidth: i32,\r\n    fgColor: i32,\r\n    bgColor: i32,\r\n): void {\r\n    let tilePriority: bool = false,\r\n        transparentColor0: bool = false,\r\n        tileColor: i32 = 0,\r\n        paletteBaseIndex: i32 = 0,\r\n        nameTableAddr: i32 = nameTableBaseAddr,\r\n        x1: i32 = x - borderWidth + (hScroll << (screenMode === MODE_TEXT_80 ? 1 : 0));\r\n    if (x1 >= scrollWidth) {\r\n        x1 -= scrollWidth;\r\n        nameTableAddr ^= hPageSize;\r\n    }\r\n    let charNo: i32,\r\n        bitShift: i32,\r\n        bit: i32,\r\n        patternAddr: i32,\r\n        patternByte: i32,\r\n        colorByte: i32 = 0,\r\n        tileAttributeByte: i32 = 0,\r\n        tilePaletteBaseIndex: i32 = 0,\r\n        lineOffset1: i32;\r\n    switch (screenMode) {\r\n        case MODE_GRAPHICS:\r\n            nameTableAddr += (x1 >> 3) + rowOffset;\r\n            charNo = getRAMByte(nameTableAddr);\r\n            bitShift = x1 & 7;\r\n            lineOffset1 = lineOffset;\r\n            if (tileColorMode !== COLOR_MODE_NORMAL) {\r\n                tileAttributeByte = getRAMByte(colorTable + (ecmPositionAttributes ? nameTableAddr - nameTableCanonicalBase : charNo));\r\n                tilePriority = (tileAttributeByte & 0x80) !== 0;\r\n                if ((tileAttributeByte & 0x40) !== 0) {\r\n                    // Flip X\r\n                    bitShift = 7 - bitShift;\r\n                }\r\n                if ((tileAttributeByte & 0x20) !== 0) {\r\n                    // Flip y\r\n                    lineOffset1 = 7 - lineOffset1;\r\n                }\r\n                transparentColor0 = (tileAttributeByte & 0x10) !== 0;\r\n            }\r\n            bit = 0x80 >> bitShift;\r\n            patternAddr = charPatternTable + (charNo << 3) + lineOffset1;\r\n            patternByte = getRAMByte(patternAddr);\r\n            switch (tileColorMode) {\r\n                case COLOR_MODE_NORMAL:\r\n                    const colorSet: i32 = getRAMByte(colorTable + (charNo >> 3));\r\n                    tileColor = (patternByte & bit) !== 0 ? (colorSet & 0xF0) >> 4 : colorSet & 0x0F;\r\n                    tilePaletteBaseIndex = tilePaletteSelect;\r\n                    transparentColor0 = true;\r\n                    tilePriority = false;\r\n                    break;\r\n                case COLOR_MODE_ECM_1:\r\n                    tileColor = ((patternByte & bit) >> (7 - bitShift));\r\n                    tilePaletteBaseIndex = (tilePaletteSelect & 0x20) | ((tileAttributeByte & 0x0f) << 1);\r\n                    break;\r\n                case COLOR_MODE_ECM_2:\r\n                    tileColor =\r\n                        ((patternByte & bit) >> (7 - bitShift)) |\r\n                        (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1);\r\n                    tilePaletteBaseIndex = ((tileAttributeByte & 0x0f) << 2);\r\n                    break;\r\n                case COLOR_MODE_ECM_3:\r\n                    tileColor =\r\n                        ((patternByte & bit) >> (7 - bitShift)) |\r\n                        (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1) |\r\n                        (((getRAMByte((patternAddr + (tilePlaneOffset << 1)) & 0x3fff) & bit) >> (7 - bitShift)) << 2);\r\n                    tilePaletteBaseIndex = ((tileAttributeByte & 0x0e) << 2);\r\n                    break;\r\n            }\r\n            paletteBaseIndex = tilePaletteBaseIndex;\r\n            break;\r\n        case MODE_BITMAP:\r\n            charNo = getRAMByte(nameTableAddr + (x1 >> 3) + rowOffset);\r\n            bitShift = x1 & 7;\r\n            bit = 0x80 >> bitShift;\r\n            const charSetOffset: i32 = (y & 0xC0) << 5;\r\n            patternByte = getRAMByte(charPatternTable + (((charNo << 3) + charSetOffset) & patternTableMask) + lineOffset);\r\n            const colorAddr: i32 = colorTable + (((charNo << 3) + charSetOffset) & colorTableMask) + lineOffset;\r\n            colorByte = getRAMByte(colorAddr);\r\n            tileColor = (patternByte & bit) !== 0 ? (colorByte & 0xF0) >> 4 : (colorByte & 0x0F);\r\n            paletteBaseIndex = tilePaletteSelect;\r\n            transparentColor0 = true;\r\n            break;\r\n        case MODE_TEXT:\r\n        case MODE_TEXT_80:\r\n            if (x >= borderWidth && x < drawWidth - borderWidth) {\r\n                nameTableAddr += x1 / 6 + rowOffset;\r\n                charNo = getRAMByte(nameTableAddr);\r\n                bitShift = x1 % 6;\r\n                lineOffset1 = lineOffset;\r\n                if (tileColorMode !== COLOR_MODE_NORMAL) {\r\n                    tileAttributeByte = getRAMByte(colorTable + (ecmPositionAttributes ? nameTableAddr - nameTableCanonicalBase : charNo));\r\n                    tilePriority = (tileAttributeByte & 0x80) !== 0;\r\n                    if ((tileAttributeByte & 0x40) !== 0) {\r\n                        // Flip X\r\n                        bitShift = 5 - bitShift;\r\n                    }\r\n                    if ((tileAttributeByte & 0x20) !== 0) {\r\n                        // Flip y\r\n                        lineOffset1 = 7 - lineOffset1;\r\n                    }\r\n                    transparentColor0 = (tileAttributeByte & 0x10) !== 0;\r\n                }\r\n                bit = 0x80 >> bitShift;\r\n                patternAddr = charPatternTable + (charNo << 3) + lineOffset1;\r\n                patternByte = getRAMByte(patternAddr);\r\n                switch (tileColorMode) {\r\n                    case COLOR_MODE_NORMAL:\r\n                        if (unlocked && ecmPositionAttributes) {\r\n                            tileAttributeByte = getRAMByte(colorTable + nameTableAddr - nameTableCanonicalBase);\r\n                            tileColor = (patternByte & bit) !== 0 ? tileAttributeByte >> 4 : tileAttributeByte & 0xF;\r\n                        } else {\r\n                            tileColor = (patternByte & bit) !== 0 ? fgColor : bgColor;\r\n                        }\r\n                        tilePaletteBaseIndex = tilePaletteSelect;\r\n                        transparentColor0 = true;\r\n                        tilePriority = false;\r\n                        break;\r\n                    case COLOR_MODE_ECM_1:\r\n                        tileColor = ((patternByte & bit) >> (7 - bitShift));\r\n                        tilePaletteBaseIndex = (tilePaletteSelect & 0x20) | ((tileAttributeByte & 0x0f) << 1);\r\n                        break;\r\n                    case COLOR_MODE_ECM_2:\r\n                        tileColor =\r\n                            ((patternByte & bit) >> (7 - bitShift)) |\r\n                            (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1);\r\n                        tilePaletteBaseIndex = ((tileAttributeByte & 0x0f) << 2);\r\n                        break;\r\n                    case COLOR_MODE_ECM_3:\r\n                        tileColor =\r\n                            ((patternByte & bit) >> (7 - bitShift)) |\r\n                            (((getRAMByte((patternAddr + tilePlaneOffset) & 0x3fff) & bit) >> (7 - bitShift)) << 1) |\r\n                            (((getRAMByte((patternAddr + (tilePlaneOffset << 1)) & 0x3fff) & bit) >> (7 - bitShift)) << 2);\r\n                        tilePaletteBaseIndex = ((tileAttributeByte & 0x0e) << 2);\r\n                        break;\r\n                }\r\n            } else {\r\n                transparentColor0 = true;\r\n            }\r\n            break;\r\n        case MODE_MULTICOLOR:\r\n            charNo = getRAMByte(nameTableAddr + (x1 >> 3) + rowOffset);\r\n            colorByte = getRAMByte(charPatternTable + (charNo << 3) + ((y1 & 0x1c) >> 2));\r\n            tileColor = (x1 & 4) === 0 ? (colorByte & 0xf0) >> 4 : (colorByte & 0x0f);\r\n            paletteBaseIndex = tilePaletteSelect;\r\n            transparentColor0 = true;\r\n            break;\r\n    }\r\n    pixelTilePriority = tilePriority;\r\n    pixelTransparentColor0 = transparentColor0;\r\n    pixelColor = tileColor;\r\n    pixelPaletteBaseIndex = paletteBaseIndex;\r\n}\r\n\r\nfunction prepareSprites(\r\n    y: i32,\r\n    drawWidth: i32,\r\n    screenMode: i32,\r\n    row30Enabled: bool,\r\n    unlocked: bool,\r\n    spriteLinkingEnabled: bool,\r\n    realSpriteYCoord: bool,\r\n    maxSprites: i32,\r\n    maxScanlineSprites: i32,\r\n    spriteColorMode: i32,\r\n    spritePaletteSelect: i32,\r\n    spritePlaneOffset: i32,\r\n    defaultSpriteSize: i32,\r\n    spriteMag: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    statusRegister: u8\r\n): u8 {\r\n    initSpriteBuffer(drawWidth);\r\n    let spritesOnLine: i32 = 0;\r\n    const outOfScreenY: i32 = row30Enabled ? 0xF0 : 0xC0;\r\n    const negativeScreenY: i32 = row30Enabled ? 0xF0 : 0xD0;\r\n    const maxSpriteAttrAddr: i32 = spriteAttributeTable + (maxSprites << 2);\r\n    for (let spriteAttrAddr: i32 = spriteAttributeTable, index: i32 = 0;\r\n         (row30Enabled || getRAMByte(spriteAttrAddr) !== 0xd0) && spriteAttrAddr < maxSpriteAttrAddr && spritesOnLine <= maxScanlineSprites; spriteAttrAddr += 4, index++) {\r\n        let parentSpriteAttrAddr: i32 = -1;\r\n        if (spriteLinkingEnabled) {\r\n            const spriteLinkingAttr: i32 = getRAMByte(spriteAttributeTable + 0x80 + ((spriteAttrAddr - spriteAttributeTable) >> 2));\r\n            if ((spriteLinkingAttr & 0x20) !== 0) {\r\n                parentSpriteAttrAddr = spriteAttributeTable + ((spriteLinkingAttr & 0x1F) << 2);\r\n            }\r\n        }\r\n        let spriteY: i32 = <i32> getRAMByte(spriteAttrAddr);\r\n        if (parentSpriteAttrAddr !== -1) {\r\n            spriteY = (spriteY + getRAMByte(parentSpriteAttrAddr)) & 0xFF;\r\n        }\r\n        if (!realSpriteYCoord) {\r\n            spriteY++;\r\n        }\r\n        if (spriteY < outOfScreenY || spriteY > negativeScreenY) {\r\n            if (spriteY > negativeScreenY) {\r\n                spriteY -= 256;\r\n            }\r\n            const spriteAttr: i32 = getRAMByte(spriteAttrAddr + 3);\r\n            const spriteSize: i32 = !unlocked || (spriteAttr & 0x10) === 0 ? defaultSpriteSize : 1;\r\n            const spriteHeight: i32 = 8 << spriteSize; // 8 or 16\r\n            const spriteDimensionY: i32 = spriteHeight << spriteMag; // 8, 16 or 32\r\n            if (y >= spriteY && y < spriteY + spriteDimensionY) {\r\n                if (spritesOnLine < maxScanlineSprites) {\r\n                    //noinspection JSSuspiciousNameCombination\r\n                    const spriteWidth: i32 = spriteHeight;\r\n                    //noinspection JSSuspiciousNameCombination\r\n                    const spriteDimensionX: i32 = spriteDimensionY;\r\n                    let spriteX: i32 = getRAMByte(spriteAttrAddr + 1);\r\n                    if (parentSpriteAttrAddr === -1) {\r\n                        if ((spriteAttr & 0x80) !== 0) {\r\n                            spriteX -= 32; // Early clock\r\n                        }\r\n                    } else {\r\n                        // Linked\r\n                        spriteX = (spriteX + getRAMByte(parentSpriteAttrAddr + 1)) & 0xFF;\r\n                        if ((getRAMByte(parentSpriteAttrAddr + 3) & 0x80) !== 0) {\r\n                            spriteX -= 32; // Early clock of parent\r\n                        }\r\n                    }\r\n                    const patternNo: i32 = (getRAMByte(spriteAttrAddr + 2) & (spriteSize !== 0 ? 0xFC : 0xFF));\r\n                    const spriteFlipY: bool = unlocked && (spriteAttr & 0x20) !== 0;\r\n                    const spriteFlipX: bool = unlocked && (spriteAttr & 0x40) !== 0;\r\n                    const baseColor: i32 = spriteAttr & 0x0F;\r\n                    let sprPaletteBaseIndex: i32 = 0;\r\n                    switch (spriteColorMode) {\r\n                        case COLOR_MODE_NORMAL:\r\n                            sprPaletteBaseIndex = spritePaletteSelect;\r\n                            break;\r\n                        case COLOR_MODE_ECM_1:\r\n                            sprPaletteBaseIndex = (spritePaletteSelect & 0x20) | (baseColor << 1);\r\n                            break;\r\n                        case COLOR_MODE_ECM_2:\r\n                            sprPaletteBaseIndex = (baseColor << 2);\r\n                            break;\r\n                        case COLOR_MODE_ECM_3:\r\n                            sprPaletteBaseIndex = ((baseColor & 0x0e) << 2);\r\n                            break;\r\n                    }\r\n                    const spritePatternBaseAddr = spritePatternTable + (patternNo << 3);\r\n                    let dy: i32 = (y - spriteY) >> spriteMag;\r\n                    if (spriteFlipY) {\r\n                        dy = spriteHeight - dy - 1;\r\n                    }\r\n                    for (let dx: i32 = 0; dx < spriteWidth; dx += 8) {\r\n                        const spritePatternAddr: i32 = spritePatternBaseAddr + dy + (dx << 1);\r\n                        const spritePatternByte0: i32 = getRAMByte(spritePatternAddr);\r\n                        const spritePatternByte1: i32 = getRAMByte((spritePatternAddr + spritePlaneOffset) & 0x3fff);\r\n                        const spritePatternByte2: i32 = getRAMByte((spritePatternAddr + (spritePlaneOffset << 1)) & 0x3fff);\r\n                        let spriteBit: i32 = 0x80;\r\n                        let spriteBitShift2: i32 = 7;\r\n                        for (let spriteBitShift1: i32 = 0; spriteBitShift1 < 8; spriteBitShift1++) {\r\n                            let sprColor: i32 = 0;\r\n                            let pixelOn: bool = false;\r\n                            switch (spriteColorMode) {\r\n                                case COLOR_MODE_NORMAL:\r\n                                    pixelOn = (spritePatternByte0 & spriteBit) !== 0;\r\n                                    sprColor = pixelOn ? baseColor : 0;\r\n                                    break;\r\n                                case COLOR_MODE_ECM_1:\r\n                                    sprColor = (spritePatternByte0 & spriteBit) >> spriteBitShift2;\r\n                                    break;\r\n                                case COLOR_MODE_ECM_2:\r\n                                    sprColor =\r\n                                        ((spritePatternByte0 & spriteBit) >> spriteBitShift2) |\r\n                                        (((spritePatternByte1 & spriteBit) >> spriteBitShift2) << 1);\r\n                                    break;\r\n                                case COLOR_MODE_ECM_3:\r\n                                    sprColor =\r\n                                        ((spritePatternByte0 & spriteBit) >> spriteBitShift2) |\r\n                                        (((spritePatternByte1 & spriteBit) >> spriteBitShift2) << 1) |\r\n                                        (((spritePatternByte2 & spriteBit) >> spriteBitShift2) << 2);\r\n                                    break;\r\n                            }\r\n                            if (sprColor > 0 || pixelOn) {\r\n                                let x2: i32 = spriteX + ((spriteFlipX ? spriteDimensionX - (dx + spriteBitShift1) - 1 : dx + spriteBitShift1) << spriteMag);\r\n                                if (x2 >= 0 && x2 < drawWidth) {\r\n                                    if (getSpriteColorBuffer(x2) === 0) {\r\n                                        setSpriteColorBuffer(x2, sprColor + 1); // Add one here so 0 means uninitialized. Subtract one before drawing.\r\n                                        setSpritePaletteBaseIndexBuffer(x2, sprPaletteBaseIndex);\r\n                                    } else {\r\n                                        statusRegister |= 0x20; // Collision\r\n                                    }\r\n                                }\r\n                                if (spriteMag) {\r\n                                    x2++;\r\n                                    if (x2 >= 0 && x2 < drawWidth) {\r\n                                        if (getSpriteColorBuffer(x2) === 0) {\r\n                                            setSpriteColorBuffer(x2, sprColor + 1); // Add one here so 0 means uninitialized. Subtract one before drawing.\r\n                                            setSpritePaletteBaseIndexBuffer(x2, sprPaletteBaseIndex);\r\n                                        } else {\r\n                                            statusRegister |= 0x20; // Collision\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            spriteBit >>= 1;\r\n                            spriteBitShift2--;\r\n                        }\r\n                    }\r\n                }\r\n                spritesOnLine++;\r\n                if (spritesOnLine === 5 && (statusRegister & 0x40) === 0) {\r\n                    statusRegister |= 0x40; // Fifth sprite\r\n                    statusRegister = <u8> ((statusRegister & 0xe0) | index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (screenMode === MODE_TEXT_80) {\r\n        for (let x1: i32 = drawWidth >> 1; x1 >= 0; x1--) {\r\n            const spriteColorBufferValue = getSpriteColorBuffer(x1);\r\n            const spritePaletteBaseIndexBufferValue = getSpritePaletteBaseIndexBuffer(x1);\r\n            setSpriteColorBuffer(x1 << 1, spriteColorBufferValue);\r\n            setSpritePaletteBaseIndexBuffer(x1 << 1, spritePaletteBaseIndexBufferValue);\r\n            setSpriteColorBuffer((x1 << 1) + 1, spriteColorBufferValue);\r\n            setSpritePaletteBaseIndexBuffer((x1 << 1) + 1, spritePaletteBaseIndexBufferValue);\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getRAMByte(addr: i32): u8 {\r\n    return load<u8>(vdpRAMAddr + addr);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getColor(i: i32): u32 {\r\n    return load<u32>(paletteAddr + (i << 2));\r\n}\r\n\r\nfunction initSpriteBuffer(drawWidth: i32): void {\r\n    memory.fill(spriteColorBufferAddr, 0x00, drawWidth << 2);\r\n    memory.fill(spritePaletteBaseIndexBufferAddr, 0x00, drawWidth << 2);\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpriteColorBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spriteColorBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpriteColorBuffer(offset: i32): i32 {\r\n    return load<i32>(spriteColorBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpritePaletteBaseIndexBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spritePaletteBaseIndexBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpritePaletteBaseIndexBuffer(offset: i32): i32 {\r\n    return load<i32>(spritePaletteBaseIndexBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction setImageData(addr: i32, value: u32): void {\r\n    store<u32>(scanlineColorBufferAddr + (addr << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getImageData(addr: i32): u32 {\r\n    return load<u32>(scanlineColorBufferAddr + (addr << 2));\r\n}\r\n"]}