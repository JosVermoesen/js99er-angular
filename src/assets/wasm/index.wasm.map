{"version":3,"sources":["~lib/rt/common.ts","assembly/tms9918a.ts","assembly/f18a.ts"],"names":[],"mappings":"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","sourceRoot":"./index","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","const MODE_GRAPHICS = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_BITMAP = 2;\r\nconst MODE_MULTICOLOR = 3;\r\nconst MODE_BITMAP_TEXT = 4;\r\nconst MODE_BITMAP_MULTICOLOR = 5;\r\nconst MODE_ILLEGAL = 6;\r\n\r\nconst vdpRAMAddr = 0x0000;\r\nconst paletteAddr = 0x4000;\r\nconst scanlineColorBufferAddr = 0x5000;\r\nconst spriteBufferAddr = 0x6000;\r\n\r\nexport function drawScanline(\r\n    y: i32,\r\n    width: i32,\r\n    height: i32,\r\n    screenMode: i32,\r\n    textMode: bool,\r\n    bitmapMode: bool,\r\n    fgColor: i32,\r\n    bgColor: i32,\r\n    nameTable: i32,\r\n    colorTable: i32,\r\n    charPatternTable: i32,\r\n    colorTableMask: i32,\r\n    patternTableMask: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    vr1: i32,\r\n    vr4: i32,\r\n    displayOn: bool,\r\n    statusRegister: u8\r\n): u8 {\r\n    const\r\n        drawWidth: i32 = !textMode ? 256 : 240,\r\n        drawHeight: i32 = 192,\r\n        hBorder: i32 = (width - drawWidth) >> 1,\r\n        vBorder: i32 = (height - drawHeight) >> 1,\r\n        spriteSize: bool = (vr1 & 0x2) !== 0,\r\n        spriteMagnify: i32 = vr1 & 0x1,\r\n        spriteDimension: i32 = (spriteSize ? 16 : 8) << (spriteMagnify ? 1 : 0),\r\n        maxSpritesOnLine: i32 = 4;\r\n    let\r\n        imageDataAddr: i32 = 0,\r\n        collision: bool = false,\r\n        fifthSprite: bool = false,\r\n        fifthSpriteIndex: u8 = 31,\r\n        x: i32,\r\n        color: i32 = 0,\r\n        rgbColor: u32,\r\n        name: i32,\r\n        tableOffset: i32,\r\n        colorByte: i32,\r\n        patternByte: i32;\r\n\r\n    if (y >= vBorder && y < vBorder + drawHeight && displayOn) {\r\n        const yScreen: i32 = y - vBorder;\r\n        // Pre-process sprites\r\n        if (!textMode) {\r\n            initSpriteBuffer();\r\n            let spritesOnLine: i32 = 0;\r\n            let endMarkerFound: bool = false;\r\n            let spriteAttributeAddr: i32 = spriteAttributeTable;\r\n            let spriteIndex: i32;\r\n            for (spriteIndex = 0; spriteIndex < 32 && spritesOnLine <= maxSpritesOnLine && !endMarkerFound; spriteIndex++) {\r\n                let ySpriteTop: i32 = getRAMByte(spriteAttributeAddr);\r\n                if (ySpriteTop !== 0xD0) {\r\n                    if (ySpriteTop > 0xD0) {\r\n                        ySpriteTop -= 256;\r\n                    }\r\n                    ySpriteTop++;\r\n                    const ySpriteBottom: i32 = ySpriteTop + spriteDimension;\r\n                    let yAdjusted: i32 = -1;\r\n                    if (spriteIndex < 8 || !bitmapMode || (vr4 & 0x03) === 3) {\r\n                        if (yScreen >= ySpriteTop && yScreen < ySpriteBottom) {\r\n                            yAdjusted = yScreen;\r\n                        }\r\n                    } else {\r\n                        // Emulate sprite duplication bug\r\n                        const yMasked: i32 = (yScreen - 1) & (((vr4 & 0x03) << 6) | 0x3F);\r\n                        if (yMasked >= ySpriteTop && yMasked < ySpriteBottom) {\r\n                            yAdjusted = yMasked;\r\n                        } else if (yScreen >= 64 && yScreen < 128 && yScreen >= ySpriteTop && yScreen < ySpriteBottom) {\r\n                            yAdjusted = yScreen;\r\n                        }\r\n                    }\r\n                    if (yAdjusted !== -1) {\r\n                        if (spritesOnLine < maxSpritesOnLine) {\r\n                            let xSprite: i32 = getRAMByte(spriteAttributeAddr + 1);\r\n                            const sPatternNo: i32 = getRAMByte(spriteAttributeAddr + 2) & (spriteSize ? 0xFC : 0xFF);\r\n                            const sColor: i32 = getRAMByte(spriteAttributeAddr + 3) & 0x0F;\r\n                            if ((getRAMByte(spriteAttributeAddr + 3) & 0x80) !== 0) {\r\n                                xSprite -= 32;\r\n                            }\r\n                            const sLine: i32 = (yAdjusted - ySpriteTop) >> spriteMagnify;\r\n                            const sPatternBase: i32 = spritePatternTable + (sPatternNo << 3) + sLine;\r\n                            for (let sx1: i32 = 0; sx1 < spriteDimension; sx1++) {\r\n                                const sx2: i32 = xSprite + sx1;\r\n                                if (sx2 >= 0 && sx2 < drawWidth) {\r\n                                    const sx3: i32 = sx1 >> spriteMagnify;\r\n                                    const sPatternByte: i32 = getRAMByte(sPatternBase + (sx3 >= 8 ? 16 : 0));\r\n                                    if ((sPatternByte & (0x80 >> (sx3 & 0x07))) !== 0) {\r\n                                        if (getSpriteBuffer(sx2) === -1) {\r\n                                            setSpriteBuffer(sx2, sColor);\r\n                                        } else {\r\n                                            collision = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        spritesOnLine++;\r\n                    }\r\n                    spriteAttributeAddr += 4;\r\n                } else {\r\n                    endMarkerFound = true;\r\n                }\r\n            }\r\n            if (spritesOnLine === 5 && !fifthSprite) {\r\n                fifthSprite = true;\r\n                fifthSpriteIndex = <u8> spriteIndex - 1;\r\n            }\r\n        }\r\n        // Draw\r\n        const rowOffset: i32 = !textMode ? (yScreen >> 3) << 5 : (yScreen >> 3) * 40;\r\n        let lineOffset: i32 = yScreen & 7;\r\n        for (x = 0; x < width; x++) {\r\n            if (x >= hBorder && x < hBorder + drawWidth) {\r\n                const x1: i32 = x - hBorder;\r\n                // Tiles\r\n                switch (screenMode) {\r\n                    case MODE_GRAPHICS:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        colorByte = getRAMByte(colorTable + (name >> 3));\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_BITMAP:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        colorByte = getRAMByte(colorTable + (tableOffset & colorTableMask) + lineOffset);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (yScreen & 0x1C) >> 2;\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (yScreen & 0x1C) >> 2;\r\n                        tableOffset = ((yScreen & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_ILLEGAL:\r\n                        color = (x1 & 4) === 0 ? fgColor : bgColor;\r\n                        break;\r\n                }\r\n                if (color === 0) {\r\n                    color = bgColor;\r\n                }\r\n                // Sprites\r\n                if (!textMode) {\r\n                    const spriteColor: i32 = getSpriteBuffer(x1);\r\n                    if (spriteColor > 0) {\r\n                        color = spriteColor;\r\n                    }\r\n                }\r\n            } else {\r\n                color = bgColor;\r\n            }\r\n            rgbColor = getColor(color);\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    } else {\r\n        // Top/bottom border\r\n        rgbColor = getColor(bgColor);\r\n        for (x = 0; x < width; x++) {\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    }\r\n    if (y === vBorder + drawHeight) {\r\n        statusRegister |= 0x80;\r\n    }\r\n    if (collision) {\r\n        statusRegister |= 0x20;\r\n    }\r\n    if ((statusRegister & 0x40) === 0) {\r\n        statusRegister = (statusRegister & 0xe0) | fifthSpriteIndex;\r\n        if (fifthSprite) {\r\n            statusRegister |= 0x40;\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getRAMByte(addr: i32): u8 {\r\n    return load<u8>(vdpRAMAddr + addr);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getColor(i: i32): u32 {\r\n    return load<u32>(paletteAddr + (i << 2));\r\n}\r\n\r\nfunction initSpriteBuffer(): void {\r\n    memory.fill(spriteBufferAddr, 0xff, 256 << 2);\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpriteBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spriteBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpriteBuffer(offset: i32): i32 {\r\n    return load<i32>(spriteBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction setImageData(addr: i32, value: u32): void {\r\n    store<u32>(scanlineColorBufferAddr + (addr << 2), value);\r\n}\r\n","export function drawScanline(): i32 {\r\n    return 1;\r\n}\r\n"]}