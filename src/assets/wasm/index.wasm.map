{"version":3,"sources":["~lib/rt/common.ts","assembly/index.ts"],"names":[],"mappings":"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","sourceRoot":"./index","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","const MODE_GRAPHICS = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_BITMAP = 2;\r\nconst MODE_MULTICOLOR = 3;\r\nconst MODE_BITMAP_TEXT = 4;\r\nconst MODE_BITMAP_MULTICOLOR = 5;\r\nconst MODE_ILLEGAL = 6;\r\n\r\nconst vdpRAMAddr = 0x0000;\r\nconst paletteAddr = 0x4000;\r\nconst scanlineColorBufferAddr = 0x5000;\r\nconst spriteBufferAddr = 0x6000;\r\n\r\nexport function drawScanline(\r\n    y: i32,\r\n    width: i32,\r\n    height: i32,\r\n    screenMode: i32,\r\n    textMode: bool,\r\n    bitmapMode: bool,\r\n    fgColor: i32,\r\n    bgColor: i32,\r\n    nameTable: i32,\r\n    colorTable: i32,\r\n    charPatternTable: i32,\r\n    colorTableMask: i32,\r\n    patternTableMask: i32,\r\n    spriteAttributeTable: i32,\r\n    spritePatternTable: i32,\r\n    vr1: i32,\r\n    vr4: i32,\r\n    displayOn: bool,\r\n    statusRegister: u8\r\n): u8 {\r\n    const\r\n        drawWidth: i32 = !textMode ? 256 : 240,\r\n        drawHeight: i32 = 192,\r\n        hBorder: i32 = (width - drawWidth) >> 1,\r\n        vBorder: i32 = (height - drawHeight) >> 1,\r\n        spriteSize: bool = (vr1 & 0x2) !== 0,\r\n        spriteMagnify: i32 = vr1 & 0x1,\r\n        spriteDimension: i32 = (spriteSize ? 16 : 8) << (spriteMagnify ? 1 : 0),\r\n        maxSpritesOnLine: i32 = 4;\r\n    let\r\n        imageDataAddr: i32 = 0,\r\n        collision: bool = false,\r\n        fifthSprite: bool = false,\r\n        fifthSpriteIndex: u8 = 31,\r\n        x: i32,\r\n        color: i32 = 0,\r\n        rgbColor: u32,\r\n        name: i32,\r\n        tableOffset: i32,\r\n        colorByte: i32,\r\n        patternByte: i32;\r\n\r\n    if (y >= vBorder && y < vBorder + drawHeight && displayOn) {\r\n        const y1: i32 = y - vBorder;\r\n        // Pre-process sprites\r\n        if (!textMode) {\r\n            initSpriteBuffer();\r\n            let spritesOnLine: i32 = 0;\r\n            let endMarkerFound: bool = false;\r\n            let spriteAttributeAddr: i32 = spriteAttributeTable;\r\n            let s: i32;\r\n            for (s = 0; s < 32 && spritesOnLine <= maxSpritesOnLine && !endMarkerFound; s++) {\r\n                let sy: i32 = getRAMByte(spriteAttributeAddr);\r\n                if (sy !== 0xD0) {\r\n                    if (sy > 0xD0) {\r\n                        sy -= 256;\r\n                    }\r\n                    sy++;\r\n                    const sy1: i32 = sy + spriteDimension;\r\n                    let y2: i32 = -1;\r\n                    if (s < 8 || !bitmapMode || (vr4 & 0x03) === 3) {\r\n                        if (y1 >= sy && y1 < sy1) {\r\n                            y2 = y1;\r\n                        }\r\n                    } else {\r\n                        // Emulate sprite duplication bug\r\n                        const yMasked: i32 = (y1 - 1) & (((vr4 & 0x03) << 6) | 0x3F);\r\n                        if (yMasked >= sy && yMasked < sy1) {\r\n                            y2 = yMasked;\r\n                        } else if (y1 >= 64 && y1 < 128 && y1 >= sy && y1 < sy1) {\r\n                            y2 = y1;\r\n                        }\r\n                    }\r\n                    if (y2 !== -1) {\r\n                        if (spritesOnLine < maxSpritesOnLine) {\r\n                            let sx: i32 = getRAMByte(spriteAttributeAddr + 1);\r\n                            const sPatternNo: i32 = getRAMByte(spriteAttributeAddr + 2) & (spriteSize ? 0xFC : 0xFF);\r\n                            const sColor: i32 = getRAMByte(spriteAttributeAddr + 3) & 0x0F;\r\n                            if ((getRAMByte(spriteAttributeAddr + 3) & 0x80) !== 0) {\r\n                                sx -= 32;\r\n                            }\r\n                            const sLine: i32 = (y2 - sy) >> spriteMagnify;\r\n                            const sPatternBase: i32 = spritePatternTable + (sPatternNo << 3) + sLine;\r\n                            for (let sx1: i32 = 0; sx1 < spriteDimension; sx1++) {\r\n                                const sx2: i32 = sx + sx1;\r\n                                if (sx2 >= 0 && sx2 < drawWidth) {\r\n                                    const sx3: i32 = sx1 >> spriteMagnify;\r\n                                    const sPatternByte: i32 = getRAMByte(sPatternBase + (sx3 >= 8 ? 16 : 0));\r\n                                    if ((sPatternByte & (0x80 >> (sx3 & 0x07))) !== 0) {\r\n                                        if (getSpriteBuffer(sx2) === -1) {\r\n                                            setSpriteBuffer(sx2, sColor);\r\n                                        } else {\r\n                                            collision = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        spritesOnLine++;\r\n                    }\r\n                    spriteAttributeAddr += 4;\r\n                } else {\r\n                    endMarkerFound = true;\r\n                }\r\n            }\r\n            if (spritesOnLine === 5 && !fifthSprite) {\r\n                fifthSprite = true;\r\n                fifthSpriteIndex = <u8> s - 1;\r\n            }\r\n        }\r\n        // Draw\r\n        const rowOffset: i32 = !textMode ? (y1 >> 3) << 5 : (y1 >> 3) * 40;\r\n        let lineOffset: i32 = y1 & 7;\r\n        for (x = 0; x < width; x++) {\r\n            if (x >= hBorder && x < hBorder + drawWidth) {\r\n                const x1: i32 = x - hBorder;\r\n                // Tiles\r\n                switch (screenMode) {\r\n                    case MODE_GRAPHICS:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        colorByte = getRAMByte(colorTable + (name >> 3));\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_BITMAP:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        tableOffset = ((y1 & 0xC0) << 5) + (name << 3);\r\n                        colorByte = getRAMByte(colorTable + (tableOffset & colorTableMask) + lineOffset);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 & 7))) !== 0 ? (colorByte & 0xF0) >> 4 : colorByte & 0x0F;\r\n                        break;\r\n                    case MODE_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (y1 & 0x1C) >> 2;\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        patternByte = getRAMByte(charPatternTable + (name << 3) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_TEXT:\r\n                        name = getRAMByte(nameTable + rowOffset + x1 / 6);\r\n                        tableOffset = ((y1 & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (patternByte & (0x80 >> (x1 % 6))) !== 0 ? fgColor : bgColor;\r\n                        break;\r\n                    case MODE_BITMAP_MULTICOLOR:\r\n                        name = getRAMByte(nameTable + rowOffset + (x1 >> 3));\r\n                        lineOffset = (y1 & 0x1C) >> 2;\r\n                        tableOffset = ((y1 & 0xC0) << 5) + (name << 3);\r\n                        patternByte = getRAMByte(charPatternTable + (tableOffset & patternTableMask) + lineOffset);\r\n                        color = (x1 & 4) === 0 ? (patternByte & 0xF0) >> 4 : patternByte & 0x0F;\r\n                        break;\r\n                    case MODE_ILLEGAL:\r\n                        color = (x1 & 4) === 0 ? fgColor : bgColor;\r\n                        break;\r\n                }\r\n                if (color === 0) {\r\n                    color = bgColor;\r\n                }\r\n                // Sprites\r\n                if (!textMode) {\r\n                    const spriteColor: i32 = getSpriteBuffer(x1);\r\n                    if (spriteColor > 0) {\r\n                        color = spriteColor;\r\n                    }\r\n                }\r\n            } else {\r\n                color = bgColor;\r\n            }\r\n            rgbColor = getColor(color);\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    } else {\r\n        // Top/bottom border\r\n        rgbColor = getColor(bgColor);\r\n        for (x = 0; x < width; x++) {\r\n            setImageData(imageDataAddr++, rgbColor);\r\n        }\r\n    }\r\n    if (y === vBorder + drawHeight) {\r\n        statusRegister |= 0x80;\r\n    }\r\n    if (collision) {\r\n        statusRegister |= 0x20;\r\n    }\r\n    if ((statusRegister & 0x40) === 0) {\r\n        statusRegister = (statusRegister & 0xe0) | fifthSpriteIndex;\r\n        if (fifthSprite) {\r\n            statusRegister |= 0x40;\r\n        }\r\n    }\r\n    return statusRegister;\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getRAMByte(addr: i32): u8 {\r\n    return load<u8>(vdpRAMAddr + addr);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getColor(i: i32): u32 {\r\n    return load<u32>(paletteAddr + (i << 2));\r\n}\r\n\r\nfunction initSpriteBuffer(): void {\r\n    memory.fill(spriteBufferAddr, 0xff, 256 << 2);\r\n}\r\n\r\n// @ts-ignore\r\n@Inline\r\nfunction setSpriteBuffer(offset: i32, value: i32): void {\r\n    store<i32>(spriteBufferAddr + (offset << 2), value);\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction getSpriteBuffer(offset: i32): i32 {\r\n    return load<i32>(spriteBufferAddr + (offset << 2));\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nfunction setImageData(addr: i32, value: u32): void {\r\n    store<u32>(scanlineColorBufferAddr + (addr << 2), value);\r\n}\r\n"]}